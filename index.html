<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Lingoegg</title>
    <style>
        :root {
            /* Theme Variables - easily customizable */
            --font-family: 'Courier New', 'monospace';
            --bg-color: #1a1a2e;
            --bg-pattern: radial-gradient(circle at 50% 50%, #16213e 0%, #1a1a2e 100%);
            --egg-color: #f5f3e7;
            --egg-pattern: linear-gradient(145deg, #f5f3e7 0%, #e8e4d0 100%);
            --egg-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            --screen-bg: #2d3436;
            --screen-color: #00b894;
            --button-a: #ff7675;
            --button-b: #74b9ff;
            --button-c: #fdcb6e;
            --button-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            --text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            --bg-image: url('images/classic.png');
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background-color: #222222;
        }

        .tamagotchi-device {
            background-image: var(--bg-image);
            width: 450px;
            height: 530px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 45px;
            padding: 50px 30px 30px 30px;
            border: 5px solid black;
            border-radius: 30px;
        }

        .screen-container {
            width: 260px;
            min-height: 350px;
            max-height: 350px;
            background: #1a1a1a;
            border-radius: 15px;
            padding: 10px;
            box-shadow: inset 0 6px 12px rgba(0, 0, 0, 0.5);
            margin-top: 45px;
            position: relative;
        }

        .screen {
            width: 100%;
            height: 100%;
            background: var(--screen-bg);
            border-radius: 6px;
            color: var(--screen-color);
            font-family: var(--font-family);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid var(--screen-color);
            font-size: 10px;
            background: rgba(0, 0, 0, 0.2);
        }

        .status-icons {
            display: flex;
            gap: 8px;
        }

        .status-icon {
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 8px;
        }

        .main-display {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }

        .pet-sprite {
            width: 80px;
            height: 80px;
            margin-bottom: 16px;
            animation: idle 3s ease-in-out infinite;
            background-image: url('images/pet-dragon-egg.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
        }

        @keyframes idle {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-4px) scale(1.05); }
        }

        .pet-name {
            font-size: 12px;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .pet-mood {
            font-size: 10px;
            opacity: 0.8;
        }

        .menu-text {
            position: absolute;
            bottom: 8px;
            left: 12px;
            right: 12px;
            font-size: 10px;
            text-align: center;
            opacity: 0.6;
        }

        .buttons-container {
            display: flex;
            justify-content: space-between;
            width: 50%;
            max-width: 340px;
            margin-top: 10px;
        }

        .button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            font-weight: bold;
            font-family: var(--font-family);
            font-size: 16px;
            cursor: pointer;
            box-shadow: var(--button-shadow);
            transition: all 0.1s ease;
            position: relative;
            border: 5px solid black;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .button-a {
            background: var(--button-a);
            color: black;
        }

        .button-b {
            background: var(--button-b);
            color: black;
            margin-top: 20px;
        }

        .button-c {
            background: var(--button-c);
            color: black;
        }

        .button-label {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: bold;
            color: #666;
            letter-spacing: 1px;
        }

        .brand-text {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            font-weight: bold;
            color: #999;
            letter-spacing: 2px;
        }

        /* Menu styles */
        .menu-container {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-bottom: 1px solid var(--screen-color);
            font-size: 10px;
            background: rgba(0, 0, 0, 0.2);
        }

        .menu-title {
            font-weight: bold;
            letter-spacing: 1px;
        }

        .menu-breadcrumb {
            font-size: 8px;
            opacity: 0.7;
        }

        .menu-content {
            flex: 1;
            padding: 6px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .menu-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border: 1px solid transparent;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .menu-item.selected {
            background: rgba(0, 184, 148, 0.2);
            border-color: var(--screen-color);
            box-shadow: 0 0 8px rgba(0, 184, 148, 0.3);
        }

        .menu-item-icon {
            margin-right: 8px;
            font-size: 14px;
        }

        .menu-item-text {
            flex: 1;
            text-align: left;
        }

        .menu-item-value {
            font-size: 10px;
            opacity: 0.8;
        }

        .menu-navigation {
            position: absolute;
            bottom: 8px;
            left: 12px;
            right: 12px;
            font-size: 9px;
            text-align: center;
            opacity: 0.6;
            display: flex;
            justify-content: space-between;
        }

        .nav-hint {
            flex: 1;
        }

        /* Learning session styles */
        .learning-container {
            display: none;
            flex-direction: column;
            height: 100%;
            text-align: center;
        }

        .character-display {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .hanzi-character {
            font-size: 40px;
            margin-bottom: 16px;
            font-weight: bold;
            color: var(--screen-color);
        }

        .pinyin-display {
            font-size: 14px;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }

        .english-display {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 16px;
        }

        .englishDisplay, .characterEnglish, #feedEnglishDisplay, #englishDisplay, #flashcardAnswerSub, #targetEnglish {
            width: 90%;
            font-size: 0.65rem;
            overflow-y: auto;
            height: 50px;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--screen-color) var(--screen-bg); /* Firefox */
        }

        .progress-indicator {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-bottom: 12px;
        }


        /* Flashcard styles */
        .flashcard-container {
            display: none;
            flex-direction: column;
            height: 100%;
            text-align: center;
        }

        .flashcard-display {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .flashcard {
            width: 200px;
            height: 120px;
            background: rgba(0, 184, 148, 0.1);
            border: 2px solid var(--screen-color);
            border-radius: 12px;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.6s ease;
            position: relative;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backface-visibility: hidden;
            border-radius: 10px;
            background: rgba(0, 184, 148, 0.1);
        }

        .flashcard-back {
            transform: rotateY(180deg);
            background: rgba(0, 184, 148, 0.2);
        }

        .flashcard-main {
            font-size: 32px;
            font-weight: bold;
            color: var(--screen-color);
            margin-bottom: 8px;
        }

        .flashcard-sub {
            font-size: 14px;
            opacity: 0.8;
        }

        .flashcard-mode {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 8px;
            opacity: 0.6;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .study-controls {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .study-button {
            padding: 8px 16px;
            background: rgba(0, 184, 148, 0.2);
            border: 1px solid var(--screen-color);
            border-radius: 6px;
            color: var(--screen-color);
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .study-button:hover {
            background: rgba(0, 184, 148, 0.3);
        }

        .study-button.active {
            background: var(--screen-color);
            color: var(--screen-bg);
        }

        .study-stats {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            opacity: 0.7;
            margin-bottom: 12px;
        }

        /* Feed/Learning styles */
        .feed-container {
            display: none;
            flex-direction: column;
            height: 100%;
            text-align: center;
        }

        .character-intro {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .new-character-badge {
            background: var(--screen-color);
            color: var(--screen-bg);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            margin-bottom: 16px;
            letter-spacing: 1px;
        }

        .character-breakdown {
            margin-top: 16px;
            padding: 12px;
            background: rgba(0, 184, 148, 0.1);
            border-radius: 8px;
            font-size: 10px;
        }

        .stroke-info {
            margin-top: 8px;
            opacity: 0.8;
        }

        /* Stats view styles */
        .stats-container {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .stats-content {
            flex: 1;
            padding: 12px;
            padding-bottom: 40px;
            overflow-y: auto;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--screen-color) var(--screen-bg); /* Firefox */
        }

        .stats-content::-webkit-scrollbar {
            width: 8px; /* Chrome, Safari, Opera */
        }

        .stats-content::-webkit-scrollbar-track {
            background: var(--screen-bg);
            border-radius: 4px;
        }

        .stats-content::-webkit-scrollbar-thumb {
            background: var(--screen-color);
            border-radius: 4px;
            border: 1px solid var(--screen-bg);
        }

        .stats-content::-webkit-scrollbar-thumb:hover {
            background: #00d2a0;
        }

        .character-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(0, 184, 148, 0.1);
            border-radius: 6px;
            font-size: 12px;
        }

        .character-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .character-hanzi {
            font-size: 18px;
            font-weight: bold;
            color: var(--screen-color);
            min-width: 48px;
        }

        .character-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
            width: 100px;
        }

        .character-pinyin {
            font-size: 11px;
            opacity: 0.9;
        }

        .character-english {
            font-size: 10px;
            opacity: 0.7;
        }

        .character-score {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        /* User Manual styles */
        .manual-section {
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(0, 184, 148, 0.1);
            border-radius: 6px;
            border-left: 3px solid var(--screen-color);
        }

        .manual-section.scrolled-up {
            opacity: 0.5;
            transform: translateY(-10px);
        }

        .manual-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .manual-icon {
            font-size: 16px;
            width: 24px;
            text-align: center;
        }

        .manual-title {
            font-size: 12px;
            font-weight: bold;
            color: var(--screen-color);
        }

        .manual-text {
            font-size: 10px;
            line-height: 1.4;
            opacity: 0.9;
            padding-left: 32px;
        }

        /* Sleep container styles */
        .sleep-container {
            display: none;
            flex-direction: column;
            height: 100%;
            text-align: center;
        }

        .sleep-display {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.1);
        }

        .sleep-pet {
            width: 80px;
            height: 80px;
            margin-bottom: 16px;
            animation: breathe 3s ease-in-out infinite;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            position: relative;
        }

        .sleep-pet::after {
            content: '💤';
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 20px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { 
                transform: scale(1); 
                opacity: 0.8;
            }
            50% { 
                transform: scale(1.05); 
                opacity: 1;
            }
        }

        .sleep-message {
            font-size: 14px;
            margin-bottom: 20px;
            color: var(--screen-color);
        }

        .sleep-progress {
            width: 150px;
            height: 8px;
            background: rgba(0, 184, 148, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .sleep-progress-bar {
            height: 100%;
            background: var(--screen-color);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .sleep-stats {
            font-size: 12px;
            opacity: 0.8;
        }

        .sleep-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            opacity: 0.6;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .score-display {
            font-size: 10px;
            font-weight: bold;
        }

        .score-stars {
            font-size: 8px;
            color: var(--screen-color);
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            opacity: 0.6;
            font-size: 12px;
        }

        /* Game container styles */
        .game-container {
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .game-display {
            flex: 1;
            padding: 12px;
            padding-bottom: 40px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .game-target {
            background: rgba(0, 184, 148, 0.1);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border: 2px solid var(--screen-color);
        }

        .target-label {
            font-size: 10px;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .target-pinyin {
            font-size: 24px;
            font-weight: bold;
            color: var(--screen-color);
            margin-bottom: 4px;
        }

        .target-english {
            font-size: 12px;
            opacity: 0.7;
        }

        .game-area {
            flex: 1;
            position: relative;
            background: rgba(0, 184, 148, 0.05);
            border-radius: 8px;
            overflow: hidden;
            min-height: 120px;
        }

        .game-bubble {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00b894, #00a085);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: transform 0.2s ease;
            animation: bubbleFloat 3s linear infinite;
            border: 2px solid var(--screen-color);
        }

        .game-bubble:hover {
            transform: scale(1.1);
        }

        .game-bubble.correct {
            background: linear-gradient(135deg, #00b894, #00a085);
            animation: bubbleCorrect 0.5s ease-out;
        }

        .game-bubble.wrong {
            background: linear-gradient(135deg, #d63031, #a71e1e);
            animation: bubbleWrong 0.5s ease-out;
        }

        @keyframes bubbleFloat {
            0% {
                transform: translateX(-50px);
            }
            100% {
                transform: translateX(250px);
            }
        }

        @keyframes bubbleCorrect {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(0); }
        }

        @keyframes bubbleWrong {
            0% { transform: scale(1); }
            25% { transform: scale(1.1) rotate(-5deg); }
            50% { transform: scale(1.1) rotate(5deg); }
            75% { transform: scale(1.1) rotate(-5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .game-ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 184, 148, 0.1);
            border-radius: 6px;
            font-size: 11px;
        }

        .game-timer {
            font-weight: bold;
        }

        .game-level {
            font-weight: bold;
        }

        /* Memory Game Styles */
        .memory-game-display {
            flex: 1;
            padding: 12px;
            padding-bottom: 40px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 4px;
            aspect-ratio: 1;
            padding: 8px;
            background: rgba(0, 184, 148, 0.05);
            border-radius: 8px;
            border: 1px solid var(--screen-color);
        }

        .memory-tile {
            background: rgba(0, 184, 148, 0.2);
            border: 1px solid var(--screen-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            color: var(--screen-color);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .memory-tile.selected {
            background: rgba(0, 184, 148, 0.4);
            border-color: #fdcb6e;
            box-shadow: 0 0 8px rgba(253, 203, 110, 0.5);
        }

        .memory-tile.flipped {
            background: rgba(0, 184, 148, 0.3);
            border-color: #74b9ff;
        }

        .memory-tile.matched {
            background: rgba(0, 184, 148, 0.6);
            border-color: #00b894;
            opacity: 0.7;
        }

        .memory-tile.hidden {
            background: rgba(0, 184, 148, 0.1);
            color: transparent;
        }

        .memory-tile .tile-content {
            text-align: center;
            line-height: 1.2;
            max-width: 100%;
            word-wrap: break-word;
        }

        .memory-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 184, 148, 0.1);
            border-radius: 6px;
            font-size: 11px;
        }

        .memory-score, .memory-timer {
            font-weight: bold;
        }

        /* Memory Game Animations */
        .memory-tile.flip-in {
            animation: memoryFlipIn 0.3s ease-in-out;
        }

        .memory-tile.flip-out {
            animation: memoryFlipOut 0.3s ease-in-out;
        }

        .memory-tile.match-animation {
            animation: memoryMatch 0.6s ease-in-out;
        }

        @keyframes memoryFlipIn {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }

        @keyframes memoryFlipOut {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }

        @keyframes memoryMatch {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background: rgba(0, 184, 148, 0.8); }
            100% { transform: scale(1); }
        }

        /* Pomodoro Timer Styles */
        .pomodoro-display {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }

        .pomodoro-type {
            font-size: 14px;
            font-weight: bold;
            color: var(--screen-color);
            margin-bottom: 16px;
            letter-spacing: 1px;
        }

        .pomodoro-type.break {
            color: #fdcb6e;
        }

        .pomodoro-timer {
            font-size: 48px;
            font-weight: bold;
            color: var(--screen-color);
            margin-bottom: 20px;
            font-family: monospace;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .pomodoro-timer.break {
            color: #fdcb6e;
        }

        .pomodoro-progress {
            width: 80%;
            height: 8px;
            background: rgba(0, 184, 148, 0.2);
            border-radius: 4px;
            margin-bottom: 16px;
            border: 1px solid var(--screen-color);
        }

        .pomodoro-progress-bar {
            height: 100%;
            background: var(--screen-color);
            border-radius: 3px;
            width: 0%;
            transition: width 1s ease;
        }

        .pomodoro-progress-bar.break {
            background: #fdcb6e;
        }

        .pomodoro-status {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .pomodoro-status.pulsing {
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* Feeding animation styles */
        .feeding-animation {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease-in;
        }

        .feeding-animation.show {
            display: flex;
        }

        .feeding-pet {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            animation: bounce 0.6s ease-in-out;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
        }

        .feeding-character {
            font-size: 40px;
            color: var(--screen-color);
            font-weight: bold;
            margin-bottom: 10px;
            animation: slideInFromTop 0.8s ease-out;
        }

        .feeding-text {
            font-size: 12px;
            color: var(--screen-color);
            opacity: 0.9;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes bounce {
            0%, 20%, 60%, 100% { transform: translateY(0); }
            40% { transform: translateY(-20px); }
            80% { transform: translateY(-10px); }
        }

        @keyframes slideInFromTop {
            0% { 
                transform: translateY(-50px);
                opacity: 0;
            }
            50% {
                opacity: 0.5;
            }
            100% { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeInUp {
            0% { 
                transform: translateY(20px);
                opacity: 0;
            }
            100% { 
                transform: translateY(0);
                opacity: 0.9;
            }
        }

        /* Pet state animations - designed for future pixel art sprites */
        .pet-sprite.full {
            animation: contentBreathe 4s ease-in-out infinite;
        }

        .pet-sprite.very-full {
            animation: sleepyFloat 5s ease-in-out infinite;
            opacity: 0.8;
        }

        @keyframes contentBreathe {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-2px) scale(1.02); }
        }

        @keyframes sleepyFloat {
            0%, 100% { transform: translateY(0px) scale(0.98) rotate(0deg); }
            25% { transform: translateY(-3px) scale(0.99) rotate(-1deg); }
            75% { transform: translateY(-1px) scale(1.01) rotate(1deg); }
        }

        /* Fullness indicator styles */
        .fullness-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 193, 7, 0.9);
            color: #333;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 11px;
            text-align: center;
            z-index: 100;
            animation: pulseWarning 2s ease-in-out infinite;
            max-width: 200px;
        }

        @keyframes pulseWarning {
            0%, 100% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* Study progress indicator */
        .study-progress-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 184, 148, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 10px;
            z-index: 50;
            animation: slideUpFade 0.3s ease-out;
        }

        @keyframes slideUpFade {
            0% { transform: translateX(-50%) translateY(20px); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="tamagotchi-device">
        <div class="screen-container">
            <div class="screen">
                <div class="status-bar">
                    <div class="status-icons">
                        <div class="status-icon">❤️ ▓▓▓▓░</div>
                        <div class="status-icon">💤 ▓▓▓▓▓</div>
                        <div class="status-icon">🍽️ ░░░░░</div>
                        <div class="status-icon sound-status"></div>
                    </div>
                    <div class="time">12:34</div>
                </div>
                
                <!-- Main Pet Display -->
                <div class="main-display" id="mainDisplay">
                    <div class="pet-sprite"></div>
                    <div class="pet-name">小龙</div>
                    <div class="pet-mood">Ready to learn!</div>
                </div>
                
                <!-- Menu System -->
                <div class="menu-container" id="menuContainer">
                    <div class="menu-header">
                        <div class="menu-title" id="menuTitle">MAIN MENU</div>
                        <div class="menu-breadcrumb" id="menuBreadcrumb">HOME</div>
                    </div>
                    <div class="menu-content" id="menuContent">
                        <!-- Menu items will be populated by JavaScript -->
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint">A: DOWN</div>
                        <div class="nav-hint">B: SELECT</div>
                        <div class="nav-hint">C: BACK</div>
                    </div>
                </div>
                
                <!-- Learning Session -->
                <div class="learning-container" id="learningContainer">
                    <div class="menu-header">
                        <div class="menu-title" id="learningTitle">LEARNING</div>
                        <div class="menu-breadcrumb" id="learningProgress">1/5</div>
                    </div>
                    <div class="character-display">
                        <div class="hanzi-character" id="hanziDisplay">你</div>
                        <div class="pinyin-display" id="pinyinDisplay">nǐ</div>
                        <div class="english-display" id="englishDisplay">you</div>
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint">A: PREV</div>
                        <div class="nav-hint">B: NEXT</div>
                        <div class="nav-hint">C: EXIT</div>
                    </div>
                </div>

                <!-- Feed System -->
                <div class="feed-container" id="feedContainer">
                    <div class="menu-header">
                        <div class="menu-title" id="feedTitle">FEEDING</div>
                        <div class="menu-breadcrumb" id="feedProgress">1/5</div>
                    </div>
                    <div class="character-intro">
                        <div class="new-character-badge">NEW WORD</div>
                        <div class="hanzi-character" id="feedHanziDisplay">你</div>
                        <div class="pinyin-display" id="feedPinyinDisplay">nǐ</div>
                        <div class="english-display" id="feedEnglishDisplay">you</div>
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint">A: SKIP</div>
                        <div class="nav-hint">B: FEED</div>
                        <div class="nav-hint">C: EXIT</div>
                    </div>
                </div>

                <!-- Flashcard Study System -->
                <div class="flashcard-container" id="flashcardContainer">
                    <div class="menu-header">
                        <div class="menu-title" id="flashcardTitle">STUDY</div>
                        <div class="menu-breadcrumb" id="flashcardProgress">1/10</div>
                    </div>
                    <div class="flashcard-display">
                        <div class="study-controls">
                            <div class="study-button active" onclick="setStudyMode('hanzi')">HANZI</div>
                            <div class="study-button" onclick="setStudyMode('pinyin')">PINYIN</div>
                            <div class="study-button" onclick="setStudyMode('english')">ENGLISH</div>
                        </div>
                        <div class="flashcard" id="flashcard" onclick="flipCard()">
                            <div class="flashcard-mode" id="flashcardMode">HANZI MODE</div>
                            <div class="flashcard-front" id="flashcardFront">
                                <div class="flashcard-main" id="flashcardQuestion">你</div>
                                <div class="flashcard-sub">Tap to reveal</div>
                            </div>
                            <div class="flashcard-back" id="flashcardBack">
                                <div class="flashcard-main" id="flashcardAnswer">nǐ</div>
                                <div class="flashcard-sub" id="flashcardAnswerSub">you</div>
                            </div>
                        </div>
                        <div class="study-stats">
                            <div>Correct: <span id="correctCount">0</span> |</div>
                            <div>&nbsp;Wrong: <span id="wrongCount">0</span> |</div>
                            <div>&nbsp;Streak: <span id="streakCount">0</span></div>
                        </div>
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint a-button">A: WRONG</div>
                        <div class="nav-hint b-button">B: FLIP</div>
                        <div class="nav-hint c-button">C: BACK</div>
                    </div>
                </div>

                <!-- Stats Browser -->
                <div class="stats-container" id="statsContainer">
                    <div class="menu-header">
                        <div class="menu-title" id="statsTitle">ALL CARDS</div>
                        <div class="menu-breadcrumb" id="statsBreadcrumb">BROWSE</div>
                    </div>
                    <div class="stats-content" id="statsContent">
                        <!-- Character cards will be populated by JavaScript -->
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint">A: SCROLL</div>
                        <div class="nav-hint">B: SCROLL</div>
                        <div class="nav-hint">C: BACK</div>
                    </div>
                </div>

                <!-- User Manual -->
                <div class="stats-container" id="userManualContainer">
                    <div class="menu-header">
                        <div class="menu-title">USER MANUAL</div>
                        <div class="menu-breadcrumb">HOW TO PLAY</div>
                    </div>
                    <div class="stats-content" id="userManualContent">
                        <h2>Pet Stats</h2>
                        <p>
                            Happiness: How content your pet is. Their happiness is affected by how well you perform in mini games and studying, as well as regular feedings. Also, if you don't feed your pet or let it stay tired for too long, it will start to lose happiness (-1 every 30 minuntes)!
                        </p>
                        <p>
                            Energy: If your pet is able to feed or study or not. When your pet's energy is zero, you must let it sleep to restore energy. You won't be able to feed, study, or play mini games until you sleep!
                        </p>
                        <p>
                            Fullness: If you've fed your pet too many new words, you can't feed anymore. To reduce fullness, you must study using flashcards and get correct answers. See below.
                        </p>
                        <hr>
                        <h2>Pet Evolutions</h2>
                        <p>
                            Your pet evolves after a certain number of feedings. In the Child, Teen, and Adult stages, your pet can evolve into one of three types depending on how well you study:
                        </p>
                        <ol>
                            <li>Fire - Performs above average in studying.</li>
                            <li>Water - Performs about average in studying.</li>
                            <li>Earth - Performs below average in studying.</li>
                        </ol>
                        <hr>

                        <h2>Mini Games</h2>

                        <h3>Pinyin Pop</h3>
                        <p>
                            Happiness:
                        </p>
                        <ul>
                            <li>If score = 0, happiness -2</li>
                            <li>If score > 0 but < 30, happiness -1</li>
                            <li>If a score is >= 30 but < 100, no change</li>
                            <li>If score >= 100, happiness +1</li>
                        </ul>

                        <p>Energy:</p>
                        <ul>
                            <li>-0.2 per session</li>
                        </ul>

                        <p>Fullness:</p>
                        <ul>
                            <li>Doesn't affect fullness.</li>
                        </ul>

                        <h3>Memory Game</h3>
                        <p>Happiness:</p>
                        <ul>
                            <li>+1 if board is successfully finished</li>
                        </ul>

                        <p>Energy:</p>
                        <ul>
                            <li>-0.1 regardless of successful completion or not.</li>
                        </ul>

                        <p>Fullness:</p>
                        <ul>
                            <li>Doesn't affect fullness.</li>
                        </ul>

                        <hr>

                        <h2>Feeding</h2>
                        <p>Every feeding session, you can learn a max of 10 new characters.</p>

                        <p>Happiness:</p>
                        <ul>
                            <li>+1 every other turn.</li>
                        </ul>

                        <p>Energy:</p>
                        <ul>
                            <li>-0.2 per session.</li>
                            <li>If energy = 0, you must sleep to restore energy.</li>
                        </ul>

                        <p>Fullness:</p>
                        <ul>
                            <li>+1 every other turn.</li>
                            <li>If fullness = 5, feeding ends, and you must study to reduce fullness.</li>
                        </ul>

                        <p>Skipping a word doesn't affect any pet stats. It adds the word to a list of skipped words.</p>

                        <hr>

                        <h2>Sleep</h2>
                        <p>Restores 1 energy every minute.</p>

                        <p>If sleep is interrupted, there is a 50% chance the pet will lose 2 happiness.</p>

                        <hr>

                        <h2>Study</h2>
                        <p>Study using flashcards to reduce fullness and increase happiness. Prioritizes words you've seen less frequently first.</p>
                        <p>Consume 0.2 energy every time a flashcard is answered (wrong or right).</p>

                        <p>Every 3 correct answers reduces fullness by 1.</p>

                        <p>Every 5 wrong answers reduces happiness by 1.</p>
                    </div>
                    <div class="menu-navigation" style="opacity: 1; background-color: #2d3436; border-radius: 5px; padding: 3px;">
                        <div class="nav-hint">A: UP</div>
                        <div class="nav-hint">B: DOWN</div>
                        <div class="nav-hint">C: BACK</div>
                    </div>
                </div>

                <!-- Pinyin Pop Game -->
                <div class="game-container" id="pinyinPopContainer">
                    <div class="menu-header">
                        <div class="menu-title" id="gameTitle">PINYIN POP</div>
                        <div class="menu-breadcrumb" id="gameStats">Score: 0 | Lives: 3</div>
                    </div>
                    <div class="game-display">
                        <div class="game-target">
                            <div class="target-pinyin" id="targetPinyin">nǐ</div>
                            <div class="target-english" id="targetEnglish">you</div>
                        </div>
                        <div class="game-area" id="gameArea">
                            <!-- Bubbles will be dynamically created here -->
                        </div>
                        <div class="game-ui">
                            <div class="game-timer">Time: <span id="gameTimer">60</span> | Level: <span id="gameLevel">1</span></div>
                        </div>
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint">Click bubbles to pop!</div>
                        <div class="nav-hint c-button">C: QUIT</div>
                    </div>
                </div>

                <!-- Memory Game -->
                <div class="game-container" id="memoryGameContainer">
                    <div class="menu-header">
                        <div class="menu-title">MEMORY GAME</div>
                        <div class="menu-breadcrumb" id="memoryGameStats">Score: 0 | Attempts: 0</div>
                    </div>
                    <div class="memory-game-display">
                        <div class="memory-grid" id="memoryGrid">
                            <!-- Memory tiles will be dynamically created here -->
                        </div>
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint">A: SELECT</div>
                        <div class="nav-hint">B: FLIP</div>
                        <div class="nav-hint">C: QUIT</div>
                    </div>
                </div>

                <!-- Pomodoro Timer -->
                <div class="game-container" id="pomodoroContainer">
                    <div class="menu-header">
                        <div class="menu-title">POMODORO TIMER</div>
                        <div class="menu-breadcrumb" id="pomodoroStats">Sessions: 0</div>
                    </div>
                    <div class="pomodoro-display">
                        <div class="pomodoro-type" id="pomodoroType">FOCUS TIME</div>
                        <div class="pomodoro-timer" id="pomodoroTimer">20:00</div>
                        <div class="pomodoro-progress">
                            <div class="pomodoro-progress-bar" id="pomodoroProgressBar"></div>
                        </div>
                        <div class="pomodoro-status" id="pomodoroStatus">Press B to start</div>
                    </div>
                    <div class="menu-navigation">
                        <div class="nav-hint">B: START/PAUSE</div>
                        <div class="nav-hint">C: QUIT</div>
                    </div>
                </div>

                <!-- Sleep Screen -->
                <div class="sleep-container" id="sleepContainer">
                    <div class="menu-header">
                        <div class="menu-title">SLEEPING</div>
                        <div class="menu-breadcrumb">RESTORING ENERGY</div>
                    </div>
                    <div class="sleep-display">
                        <div class="sleep-pet" id="sleepPet"></div>
                        <div class="sleep-message" id="sleepMessage">💤 Sleeping peacefully...</div>
                        <div class="sleep-progress">
                            <div class="sleep-progress-bar" id="sleepProgressBar"></div>
                        </div>
                        <div class="sleep-stats" id="sleepStats">Energy: 0/5</div>
                        <div class="sleep-hint">Press any button to wake up</div>
                    </div>
                </div>

                <!-- Feeding Animation Overlay -->
                <div class="feeding-animation" id="feedingAnimation">
                    <div class="feeding-pet" id="feedingPet"></div>
                    <div class="feeding-character" id="feedingCharacter">你</div>
                    <div class="feeding-text">Nom nom nom!</div>
                </div>
                
                <div class="menu-text" id="bottomHint">Press B to enter menu</div>
            </div>
        </div>
        
        <div class="buttons-container">
            <button class="button button-a" onclick="buttonPress('A')">
                A
            </button>
            <button class="button button-b" onclick="buttonPress('B')">
                B
            </button>
            <button class="button button-c" onclick="buttonPress('C')">
                C
            </button>
        </div>
        
        <div class="brand-text">Lingoegg</div>
    </div>



    <script>
        /* Todos 
        - Decide which word data set to use... both seem bad lol
        - Implement full pet evolution system with dynamic images
        - Add sound effects for actions
        - Implement a Play minigame where you match TTS audio to characters
        - Pet racing minigame like Chrome's internet offline dinosaur game
        - Pomodoro timer for study sessions
        - Click to interact with options in the menus (click = select + press B)
        - Add more themes
        - Add art for the 2 other pet types (water, earth)
        */

        // Game state
        let gameState = {
            petName: '小龙',
            petStage: 'egg', // 'egg', 'baby', 'child', 'teen', 'adult'
            petType: null, // null, 'fire', 'water', 'earth'
            totalFeedings: 0, // Track total characters fed for evolution
            happiness: 5,
            energy: 5,
            fullness: 0, // 0-5, affects ability to learn new characters
            currentTheme: 'sakura',
            currentView: 'main', // 'main', 'menu', 'learning', 'feed', 'flashcard'
            currentMenu: 'main',
            selectedMenuItem: 0,
            menuHistory: [],
            learnedCharacters: [], // Characters the pet has been "fed" - loaded from localStorage
            skippedCharacters: [], // Characters the user has skipped - loaded from localStorage
            learningSession: {
                currentIndex: 0,
                characters: [] // Dynamically populated when feeding starts
            },
            feedSession: {
                currentIndex: 0,
                characterSet: 'hsk1',
                characters: []
            },
            flashcardSession: {
                currentIndex: 0,
                mode: 'hanzi', // 'hanzi', 'pinyin', 'english'
                isFlipped: false,
                characters: [],
                stats: { correct: 0, wrong: 0, streak: 0 }
            },
            statsView: {
                scrollIndex: 0,
                viewMode: 'progress', // 'progress' or 'allcards'
                hskLevel: 'all' // HSK level filter
            },
            userManualView: {
                scrollIndex: 0
            },
            pinyinPopSession: {
                currentPinyin: '',
                currentCharacter: null,
                bubbles: [],
                score: 0,
                lives: 3,
                level: 1,
                timeLeft: 60,
                gameRunning: false,
                characters: [],
                stats: { correct: 0, wrong: 0, streak: 0 }
            },
            memoryGameSession: {
                gridSize: 4,
                tiles: [],
                flippedTiles: [],
                matchedPairs: 0,
                score: 0,
                attempts: 0,
                gameStartTime: null,
                isProcessing: false,
                characters: []
            },
            pomodoroSession: {
                isRunning: false,
                isPaused: false,
                isBreak: false,
                timeLeft: 20 * 60, // 20 minutes in seconds
                workTime: 20 * 60, // 20 minutes
                breakTime: 5 * 60, // 5 minutes
                timer: null,
                sessionsCompleted: 0
            },
            // Happiness penalty tracking
            happinessPenalties: {
                fullnessZeroSince: null,
                energyZeroSince: null,
                fullnessTimer: null,
                energyTimer: null
            },
            // Sleep system tracking
            sleepState: {
                isSleeping: false,
                sleepStartTime: null,
                sleepTimer: null
            },
            // Streak tracking
            streakData: {
                currentStreak: 0,
                lastPlayDate: null,
                longestStreak: 0
            },
            soundEnabled: true, // Sound toggle
        };

        // Evolution system
        const evolutionData = {
            stages: {
                egg: { image: 'images/pet-dragon-egg.png', name: '小龙', stage: 'egg' },
                baby: { image: 'images/pet-dragon-baby.png', name: '幼龙', stage: 'baby' },
                fireChild: { image: 'images/pet-dragon-fire-child.png', name: '火龙', stage: 'child' },
                waterChild: { image: 'images/pet-dragon-fire-child.png', name: '水龙', stage: 'child' }, // Using fire image as placeholder
                earthChild: { image: 'images/pet-dragon-fire-child.png', name: '土龙', stage: 'child' }, // Using fire image as placeholder
                fireTeen: { image: 'images/pet-dragon-fire-teen.png', name: '火龙', stage: 'teen' },
                waterTeen: { image: 'images/pet-dragon-fire-teen.png', name: '水龙', stage: 'teen' }, // Using fire image as placeholder
                earthTeen: { image: 'images/pet-dragon-fire-teen.png', name: '土龙', stage: 'teen' }, // Using fire image as placeholder
                fireAdult: { image: 'images/pet-dragon-fire-adult.png', name: '火龙王', stage: 'adult' },
                waterAdult: { image: 'images/pet-dragon-fire-adult.png', name: '水龙王', stage: 'adult' }, // Using fire image as placeholder
                earthAdult: { image: 'images/pet-dragon-fire-adult.png', name: '土龙王', stage: 'adult' } // Using fire image as placeholder
            },
            triggers: {
                eggToBaby: 3, // 3 characters fed
                babyToChild: 25, // 25 characters fed total
                childToTeen: 50, // 50 characters fed total
                teenToAdult: 100 // 100 characters fed total
            }
        };

        // Evolution functions
        function checkEvolution() {
            if (gameState.petStage === 'egg' && gameState.totalFeedings >= evolutionData.triggers.eggToBaby) {
                evolvePet('baby');
            } else if (gameState.petStage === 'baby' && gameState.totalFeedings >= evolutionData.triggers.babyToChild) {
                // Determine evolution path based on average success rate
                const averageSuccessRate = calculateAverageScore();
                let evolutionType;
                
                if (averageSuccessRate > 0.8) {
                    evolutionType = 'fireChild'; // High success rate (>80%) becomes fire dragon
                } else if (averageSuccessRate > 0.5) {
                    evolutionType = 'waterChild'; // Medium success rate (50-80%) becomes water dragon
                } else {
                    evolutionType = 'earthChild'; // Lower success rate (≤50%) becomes earth dragon
                }
                
                evolvePet(evolutionType);
            } else if (gameState.petStage === 'child' && gameState.totalFeedings >= evolutionData.triggers.childToTeen) {
                // Evolve child to teen of the same type
                let evolutionType;
                if (gameState.petType === 'fire') {
                    evolutionType = 'fireTeen';
                } else if (gameState.petType === 'water') {
                    evolutionType = 'waterTeen';
                } else if (gameState.petType === 'earth') {
                    evolutionType = 'earthTeen';
                }
                
                if (evolutionType) {
                    evolvePet(evolutionType);
                }
            } else if (gameState.petStage === 'teen' && gameState.totalFeedings >= evolutionData.triggers.teenToAdult) {
                // Evolve teen to adult of the same type
                let evolutionType;
                if (gameState.petType === 'fire') {
                    evolutionType = 'fireAdult';
                } else if (gameState.petType === 'water') {
                    evolutionType = 'waterAdult';
                } else if (gameState.petType === 'earth') {
                    evolutionType = 'earthAdult';
                }
                
                if (evolutionType) {
                    evolvePet(evolutionType);
                }
            }
        }

        function calculateAverageScore() {
            if (gameState.learnedCharacters.length === 0) return 0;
            
            // Calculate average success rate across all characters
            let totalSuccessRate = 0;
            let charactersWithAttempts = 0;
            
            gameState.learnedCharacters.forEach(char => {
                if (char.timesSeen > 0) {
                    const successRate = char.score / char.timesSeen;
                    totalSuccessRate += successRate;
                    charactersWithAttempts++;
                }
            });
            
            // If no characters have been studied yet, return 0
            if (charactersWithAttempts === 0) return 0;
            
            return totalSuccessRate / charactersWithAttempts;
        }

        function evolvePet(newType) {
            const newEvolution = evolutionData.stages[newType];
            if (!newEvolution) return;

            gameState.petStage = newEvolution.stage;
            
            // Set pet type based on evolution
            if (newType === 'baby') {
                gameState.petType = null;
            } else if (newType.includes('fire')) {
                gameState.petType = 'fire';
            } else if (newType.includes('water')) {
                gameState.petType = 'water';
            } else if (newType.includes('earth')) {
                gameState.petType = 'earth';
            }
            
            gameState.petName = newEvolution.name;

            // Update pet display
            const petSprite = document.querySelector('.pet-sprite');
            const petName = document.querySelector('.pet-name');
            
            petSprite.style.backgroundImage = `url('${newEvolution.image}')`;
            petName.textContent = newEvolution.name;

            // Show evolution animation
            showEvolutionAnimation(newEvolution);
            
            // Save evolution data
            saveEvolutionData();
        }

        function showEvolutionAnimation(evolutionData) {
            // Create evolution overlay
            const overlay = document.createElement('div');
            overlay.className = 'evolution-overlay';
            overlay.innerHTML = `
                <div class="evolution-content">
                    <div class="evolution-title">EVOLUTION!</div>
                    <div class="evolution-pet-image" style="width: 120px; height: 120px; background-image: url('${evolutionData.image}'); background-size: contain; background-repeat: no-repeat; background-position: center; image-rendering: pixelated;"></div>
                    <div class="evolution-name">${evolutionData.name}</div>
                </div>
            `;

            const screenContainer = document.querySelector('.screen-container');
            if (screenContainer) {
                // Create a fade overlay
                const fadeOverlay = document.createElement('div');
                fadeOverlay.className = 'evolution-fade-overlay';
                fadeOverlay.style.position = 'absolute';
                fadeOverlay.style.top = 0;
                fadeOverlay.style.left = 0;
                fadeOverlay.style.right = 0;
                fadeOverlay.style.bottom = 0;
                fadeOverlay.style.background = 'rgba(0,0,0,0.85)';
                fadeOverlay.style.zIndex = 999;
                fadeOverlay.style.pointerEvents = 'none';
                fadeOverlay.style.transition = 'opacity 0.4s';
                fadeOverlay.style.opacity = '1';
                fadeOverlay.style.borderRadius = '15px';
                screenContainer.appendChild(fadeOverlay);

                // Remove fade overlay when evolution overlay is removed
                const removeFade = () => {
                    if (fadeOverlay.parentNode) {
                        fadeOverlay.parentNode.removeChild(fadeOverlay);
                    }
                    document.removeEventListener('keydown', removeFade);
                };
                document.addEventListener('keydown', removeFade);
                setTimeout(removeFade, 5000);
            }
            
            // Add CSS for evolution overlay
            const style = document.createElement('style');
            style.textContent = `
                .evolution-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    animation: evolutionGlow 0.5s ease-in-out;
                }

                .evolution-content {
                    text-align: center;
                    color: white;
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                    animation: evolutionPulse 2s ease-in-out infinite;
                }

                .evolution-title {
                    font-size: 26px;
                    font-weight: bold;
                    margin-bottom: 20px;
                    letter-spacing: 3px;
                }

                .evolution-pet-image {
                    margin: 20px 0;
                    margin-left: 40px;
                    animation: evolutionPulse 2s ease-in-out infinite;
                }

                .evolution-name {
                    font-size: 24px;
                    font-weight: bold;
                    margin-bottom: 30px;
                }

                .evolution-hint {
                    font-size: 12px;
                    opacity: 0.7;
                    animation: evolutionBlink 1s ease-in-out infinite;
                }

                @keyframes evolutionGlow {
                    from { opacity: 0; transform: scale(0.8); }
                    to { opacity: 1; transform: scale(1); }
                }

                @keyframes evolutionPulse {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.05); }
                }

                @keyframes evolutionSpin {
                    0% { transform: rotate(0deg) scale(1); }
                    50% { transform: rotate(180deg) scale(1.2); }
                    100% { transform: rotate(360deg) scale(1); }
                }

                @keyframes evolutionBlink {
                    0%, 100% { opacity: 0.7; }
                    50% { opacity: 0.3; }
                }
            `;
            
            document.head.appendChild(style);
            document.body.appendChild(overlay);
            
            // Remove on any button press or after 5 seconds
            const removeOverlay = () => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
                document.removeEventListener('keydown', removeOverlay);
            };
            
            document.addEventListener('keydown', removeOverlay);
            setTimeout(removeOverlay, 5000);
        }

        function saveSound() {
            localStorage.setItem('Lingoegg_sound', JSON.stringify(gameState.soundEnabled));
            updateSoundIcon();
        }

        function loadSound() {
            const saved = localStorage.getItem('Lingoegg_sound');
            if (saved) {
                gameState.soundEnabled = JSON.parse(saved);
            } else {
                gameState.soundEnabled = true; // Default to sound enabled
            }

            updateSoundIcon();
        }

        function updateSoundIcon() {
            const soundIcon = document.querySelector('.sound-status');
            soundIcon.textContent = gameState.soundEnabled ? '🔊' : '🔇';
        }

        function saveEvolutionData() {
            const evolutionSave = {
                petStage: gameState.petStage,
                petType: gameState.petType,
                petName: gameState.petName,
                totalFeedings: gameState.totalFeedings
            };
            localStorage.setItem('Lingoegg_evolution', JSON.stringify(evolutionSave));
        }

        function loadEvolutionData() {
            const saved = localStorage.getItem('Lingoegg_evolution');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.petStage = data.petStage || 'egg';
                gameState.petType = data.petType || null;
                gameState.petName = data.petName || '小龙';
                gameState.totalFeedings = data.totalFeedings || 0;
                
                // Update pet display - find the correct evolution stage
                let currentEvolution;
                if (gameState.petStage === 'egg' || gameState.petStage === 'baby') {
                    currentEvolution = evolutionData.stages[gameState.petStage];
                } else {
                    // For child, teen, adult stages, combine type and stage
                    const evolutionKey = gameState.petType + gameState.petStage.charAt(0).toUpperCase() + gameState.petStage.slice(1);
                    currentEvolution = evolutionData.stages[evolutionKey];
                }
                
                if (currentEvolution) {
                    document.querySelector('.pet-sprite').style.backgroundImage = `url('${currentEvolution.image}')`;
                    document.querySelector('.pet-name').textContent = gameState.petName;
                }
            }
        }

        function getCurrentPetImage() {
            // Find the correct evolution stage
            let currentEvolution;
            if (gameState.petStage === 'egg' || gameState.petStage === 'baby') {
                currentEvolution = evolutionData.stages[gameState.petStage];
            } else {
                // For child, teen, adult stages, combine type and stage
                const evolutionKey = gameState.petType + gameState.petStage.charAt(0).toUpperCase() + gameState.petStage.slice(1);
                currentEvolution = evolutionData.stages[evolutionKey];
            }
            
            return currentEvolution ? currentEvolution.image : 'images/pet-dragon-baby.png';
        }

        // localStorage functions
        function saveLearnedCharacters() {
            localStorage.setItem('Lingoegg_learned', JSON.stringify(gameState.learnedCharacters));
        }

        function loadLearnedCharacters() {
            const saved = localStorage.getItem('Lingoegg_learned');
            if (saved) {
                gameState.learnedCharacters = JSON.parse(saved);
            }
        }

        function saveSkippedCharacters() {
            localStorage.setItem('Lingoegg_skipped', JSON.stringify(gameState.skippedCharacters));
        }

        function loadSkippedCharacters() {
            const saved = localStorage.getItem('Lingoegg_skipped');
            if (saved) {
                gameState.skippedCharacters = JSON.parse(saved);
            }
        }

        function savePetStats() {
            const petStats = {
                happiness: gameState.happiness,
                energy: gameState.energy,
                fullness: gameState.fullness
            };
            localStorage.setItem('Lingoegg_pet_stats', JSON.stringify(petStats));
        }

        function loadPetStats() {
            const saved = localStorage.getItem('Lingoegg_pet_stats');
            if (saved) {
                const stats = JSON.parse(saved);
                gameState.happiness = stats.happiness || 5;
                gameState.energy = stats.energy || 5;
                gameState.fullness = stats.fullness || 0;
            }
        }

        function saveStreakData() {
            const streakSave = {
                currentStreak: gameState.streakData.currentStreak,
                lastPlayDate: gameState.streakData.lastPlayDate,
                longestStreak: gameState.streakData.longestStreak
            };
            localStorage.setItem('Lingoegg_streak', JSON.stringify(streakSave));
        }

        function loadStreakData() {
            const saved = localStorage.getItem('Lingoegg_streak');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.streakData.currentStreak = data.currentStreak || 0;
                gameState.streakData.lastPlayDate = data.lastPlayDate || null;
                gameState.streakData.longestStreak = data.longestStreak || 0;
            }
        }

        function checkAndUpdateStreak() {
            const today = new Date();
            const todayDateString = today.toDateString(); // e.g., "Mon Jul 05 2025"
            
            if (!gameState.streakData.lastPlayDate) {
                // First time playing
                gameState.streakData.currentStreak = 1;
                gameState.streakData.lastPlayDate = todayDateString;
                gameState.streakData.longestStreak = Math.max(gameState.streakData.longestStreak, 1);
                saveStreakData();
                console.log('Welcome! Starting your streak: Day 1');
                return;
            }
            
            const lastPlayDate = new Date(gameState.streakData.lastPlayDate);
            const timeDiff = today.getTime() - lastPlayDate.getTime();
            const daysDiff = Math.floor(timeDiff / (1000 * 3600 * 24));
            
            if (daysDiff === 0) {
                // Same day - no change to streak
                return;
            } else if (daysDiff === 1) {
                // Consecutive day - increment streak
                gameState.streakData.currentStreak++;
                gameState.streakData.lastPlayDate = todayDateString;
                gameState.streakData.longestStreak = Math.max(gameState.streakData.longestStreak, gameState.streakData.currentStreak);
                saveStreakData();
                console.log(`Streak continued! Day ${gameState.streakData.currentStreak}`);
            } else if (daysDiff >= 2) {
                // Missed at least one day - reset streak
                const oldStreak = gameState.streakData.currentStreak;
                gameState.streakData.currentStreak = 1;
                gameState.streakData.lastPlayDate = todayDateString;
                saveStreakData();
                console.log(`Streak broken! You missed ${daysDiff - 1} day(s). Previous streak: ${oldStreak} days. Starting fresh: Day 1`);
            }
        }

        function updateStreakActivity() {
            // Call this when user actively engages with the game
            // This ensures the last play date is updated when they actually play
            const today = new Date();
            const todayDateString = today.toDateString();
            
            if (gameState.streakData.lastPlayDate !== todayDateString) {
                gameState.streakData.lastPlayDate = todayDateString;
                saveStreakData();
                // Update menu counts to reflect any changes
                updateStatsMenuCounts();
            }
        }

        function addLearnedCharacter(character) {
            // Add character with initial stats
            const learnedChar = {
                ...character,
                score: 0, // Number of times answered correctly
                timesSeen: 0, // Number of times encountered in flashcards
                dateAdded: new Date().toISOString()
            };
            gameState.learnedCharacters.push(learnedChar);
            gameState.totalFeedings++; // Increment feeding counter
            saveLearnedCharacters();
            saveEvolutionData();
            
            // Update streak activity (user engaged with the game)
            updateStreakActivity();
            
            // Check for evolution after feeding
            checkEvolution();
        }

        function addSkippedCharacter(character) {
            // Add character to skipped list with timestamp
            const skippedChar = {
                ...character,
                dateSkipped: new Date().toISOString()
            };
            gameState.skippedCharacters.push(skippedChar);
            saveSkippedCharacters();
            
            // Update streak activity (user engaged with the game)
            updateStreakActivity();
        }

        function updateCharacterScore(hanzi, isCorrect) {
            const character = gameState.learnedCharacters.find(c => c.hanzi === hanzi);
            if (character) {
                character.timesSeen++; // Always increment times seen
                if (isCorrect) {
                    character.score++; // Increment correct count
                }
                saveLearnedCharacters();
                
                // Check for evolution when scores change (might affect average)
                checkEvolution();
            }
        }

        function getAvailableCharacters(characterSet) {
            const allChars = characterSets[characterSet];
            return allChars.filter(char => 
                !gameState.learnedCharacters.some(learned => learned.hanzi === char.hanzi) &&
                !gameState.skippedCharacters.some(skipped => skipped.hanzi === char.hanzi)
            );
        }

        function getRandomCharacters(characters, count) {
            const shuffled = [...characters].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

        function sortCharactersByScore(characters) {
            // Sort by success rate ascending (lower rates first), then by date added
            return characters.sort((a, b) => {
                const successRateA = a.timesSeen > 0 ? a.score / a.timesSeen : 0;
                const successRateB = b.timesSeen > 0 ? b.score / b.timesSeen : 0;
                
                if (successRateA !== successRateB) {
                    return successRateA - successRateB;
                }
                return new Date(a.dateAdded) - new Date(b.dateAdded);
            });
        }

        // Fullness management functions
        function canLearnNewCharacters() {
            return gameState.fullness < 5 && gameState.energy > 0; // Allow learning until completely full (5) AND energy is above 0
        }

        function getFullnessMessage() {
            switch (gameState.fullness) {
                case 0: 
                case 1:
                    return "Hungry and ready to learn!";
                case 2: return "Quite satisfied!";
                case 3: return "Getting full! Study to make room.";
                case 4: return "Almost completely full!";
                case 5: return "Too full! Must study first!";
                default: return "Ready to learn!";
            }
        }

        function getSleepMessage() {
            if(gameState.energy >= 5) return "Wide awake!";
            else if(gameState.energy >= 4) return "Pretty energetic.";
            else if(gameState.energy >= 3) return "Feeling a little tired.";
            else if(gameState.energy >= 2) return "I could use a nap...";
            else if(gameState.energy >= 1) return "Almost time for bed...";
            else if(gameState.energy >= 0) return "Too sleepy to learn! Let's rest.";
            else return "Ready to learn!";
        }

        function getHappinessMessage() {
            if (gameState.happiness >= 5) return "Feeling great!";
            else if (gameState.happiness >= 4) return "Happy and content.";
            else if (gameState.happiness >= 3) return "Doing okay.";
            else if (gameState.happiness >= 2) return "A bit sad...";
            else if (gameState.happiness >= 1) return "Very unhappy!";
            else return "So sad... :(";
        }

        function updatePetState() {
            const petSprite = document.querySelector('.pet-sprite');
            const petMood = document.querySelector('.pet-mood');
            
            // Remove previous fullness classes
            petSprite.classList.remove('full', 'very-full');
            
            // Add appropriate fullness class for animations
            if (gameState.fullness >= 5) {
                petSprite.classList.add('very-full');
            } else if (gameState.fullness >= 3) {
                petSprite.classList.add('full');
            }

            const fullnessMessage = () => {
                let randomIndex = Math.floor(Math.random() * 3);
                return [
                    getFullnessMessage(),
                    getSleepMessage(),
                    getHappinessMessage()
                ][randomIndex];
            }

            // Update mood text
            petMood.innerHTML = fullnessMessage();
        }

        function reduceEnergyFromStudy() {
            if (gameState.energy > 0) {
                gameState.energy = Math.max(0, gameState.energy - 0.2);
                updateStatusBars();
                updatePetState();
            } else {
                showView('main');
            }
        }

        function reduceFullnessFromStudy() {
            if (gameState.fullness > 0) {
                gameState.fullness = Math.max(0, gameState.fullness - 1);
                updateStatusBars();
                updatePetState();
            }
        }
        function showFullnessWarning() {
            // Create warning overlay
            const warning = document.createElement('div');
            warning.className = 'fullness-warning';
            if(gameState.fullness > 5) {
                warning.innerHTML += `
                    <div>😱 Pet is overstuffed!</div>
                    <div>Study to reduce pet fullness.</div>
                `;
            } else if(gameState.energy <= 0) {
                warning.innerHTML += `
                    <div>😴 Pet is too tired!</div>
                    <div>Time for a nap before more learning.</div>
                `;
            }

            document.querySelector('.feed-container').appendChild(warning);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.parentNode.removeChild(warning);
                }
            }, 3000);
        }

        function showFatigueWarning() {
            // Create fatigue warning overlay
            const warning = document.createElement('div');
            warning.className = 'fatigue-warning';
            warning.innerHTML = `
                <div>😴 Pet is too tired!</div>
                <div>Time for a nap before more learning.</div>
            `;

            document.querySelector('.feed-container').appendChild(warning);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.parentNode.removeChild(warning);
                }
            }, 3000);
        }

        // === HAPPINESS PENALTY SYSTEM ===
        function startFullnessZeroTimer() {
            if (gameState.happinessPenalties.fullnessTimer) return; // Already running
            
            gameState.happinessPenalties.fullnessZeroSince = Date.now();
            gameState.happinessPenalties.fullnessTimer = setInterval(() => {
                if (gameState.fullness > 0) {
                    // Stop timer when fullness > 0
                    clearInterval(gameState.happinessPenalties.fullnessTimer);
                    gameState.happinessPenalties.fullnessTimer = null;
                    gameState.happinessPenalties.fullnessZeroSince = null;
                    return;
                }
                
                const timeSinceZero = Date.now() - gameState.happinessPenalties.fullnessZeroSince;
                const minutesSinceZero = Math.floor(timeSinceZero / (1000 * 60));
                
                // Every 30 minutes, decrease happiness
                if (minutesSinceZero >= 30 && minutesSinceZero % 30 === 0) {
                    gameState.happiness = Math.max(0, gameState.happiness - 1);
                    updateStatusBars();
                    updatePetState();
                    console.log(`Happiness decreased due to ${minutesSinceZero} minutes of zero fullness`);
                }
            }, 60000); // Check every minute
        }

        function startEnergyZeroTimer() {
            if (gameState.happinessPenalties.energyTimer) return; // Already running
            
            gameState.happinessPenalties.energyZeroSince = Date.now();
            gameState.happinessPenalties.energyTimer = setInterval(() => {
                if (gameState.energy > 0) {
                    // Stop timer when energy > 0
                    clearInterval(gameState.happinessPenalties.energyTimer);
                    gameState.happinessPenalties.energyTimer = null;
                    gameState.happinessPenalties.energyZeroSince = null;
                    return;
                }
                
                const timeSinceZero = Date.now() - gameState.happinessPenalties.energyZeroSince;
                const minutesSinceZero = Math.floor(timeSinceZero / (1000 * 60));
                
                // Every 30 minutes, decrease happiness
                if (minutesSinceZero >= 30 && minutesSinceZero % 30 === 0) {
                    gameState.happiness = Math.max(0, gameState.happiness - 1);
                    updateStatusBars();
                    updatePetState();
                    console.log(`Happiness decreased due to ${minutesSinceZero} minutes of zero energy`);
                }
            }, 60000); // Check every minute
        }

        function checkHappinessPenalties() {
            // Start timers when fullness or energy reach 0
            if (gameState.fullness <= 0 && !gameState.happinessPenalties.fullnessTimer) {
                startFullnessZeroTimer();
            }
            if (gameState.energy <= 0 && !gameState.happinessPenalties.energyTimer) {
                startEnergyZeroTimer();
            }
        }

        // Character databases
        // Load character sets from external JSON
        let characterSets = {};

        fetch('json/dataset.json')
            .then(response => response.json())
            .then(data => {
            characterSets = data;
            })
        .catch(err => {
            console.error('Failed to load character sets:', err);
        });

        loadSound();

        // Menu definitions
        const menus = {
            main: {
                title: 'MAIN MENU',
                breadcrumb: 'HOME',
                items: [
                    { icon: '🍚', text: 'Feed', value: 'Learn New Words', action: 'openMenu', target: 'feed' },
                    { icon: '🎮', text: 'Play', value: 'Games', action: 'openMenu', target: 'play' },
                    { icon: '📚', text: 'Study', value: 'Flashcards', action: 'openMenu', target: 'study' },
                    { icon: '💤', text: 'Sleep', value: 'Rest', action: 'sleep', target: null },
                    { icon: '📊', text: 'Stats', value: 'View Progress', action: 'openMenu', target: 'stats' },
                    { icon: '⚙️', text: 'Settings', value: 'Options', action: 'openMenu', target: 'settings' }
                ]
            },
            feed: {
                title: 'FEED PET',
                breadcrumb: 'HOME > FEED',
                items: [
                    { icon: '1️⃣', text: 'HSK 1', value: '0 new words', action: 'startFeeding', target: 'hsk1' },
                    { icon: '2️⃣', text: 'HSK 2', value: '0 new words', action: 'startFeeding', target: 'hsk2' },
                    { icon: '3️⃣', text: 'HSK 3', value: '0 new words', action: 'startFeeding', target: 'hsk3' },
                    { icon: '4️⃣', text: 'HSK 4', value: '0 new words', action: 'startFeeding', target: 'hsk4' },
                    { icon: '5️⃣', text: 'HSK 5', value: '0 new words', action: 'startFeeding', target: 'hsk5' },
                    { icon: '6️⃣', text: 'HSK 6', value: '0 new words', action: 'startFeeding', target: 'hsk6' },
                    { icon: '⏫', text: 'HSK 7-9', value: '0 new words', action: 'startFeeding', target: 'hsk789' }
                ]
            },
            play: {
                title: 'PLAY GAMES',
                breadcrumb: 'HOME > PLAY',
                items: [
                    { icon: '🫧', text: 'Pinyin Pop', value: 'Pop Bubbles', action: 'startGame', target: 'speed' },
                    { icon: '🧠', text: 'Memory Game', value: 'Match Pairs', action: 'startGame', target: 'memory' },
                    { icon: '🍅', text: 'Pomodoro Timer', value: 'Focus Session', action: 'startGame', target: 'pomodoro' }
                ]
            },
            stats: {
                title: 'STATISTICS',
                breadcrumb: 'HOME > STATS',
                items: [
                    { icon: '📈', text: 'Progress', value: 'Study Progress', action: 'openMenu', target: 'progress' },
                    { icon: '💯', text: 'Browse', value: 'All Characters', action: 'openMenu', target: 'browse' },
                    { icon: '🔥', text: 'Streak', value: '12 days', action: 'viewStats', target: 'streak' }
                ]
            },
            study: {
                title: 'STUDY',
                breadcrumb: 'HOME > STUDY',
                items: [
                    { icon: '1️⃣', text: 'HSK 1', value: '0 learned', action: 'startFlashcards', target: 'hsk1' },
                    { icon: '2️⃣', text: 'HSK 2', value: '0 learned', action: 'startFlashcards', target: 'hsk2' },
                    { icon: '3️⃣', text: 'HSK 3', value: '0 learned', action: 'startFlashcards', target: 'hsk3' },
                    { icon: '4️⃣', text: 'HSK 4', value: '0 learned', action: 'startFlashcards', target: 'hsk4' },
                    { icon: '5️⃣', text: 'HSK 5', value: '0 learned', action: 'startFlashcards', target: 'hsk5' },
                    { icon: '6️⃣', text: 'HSK 6', value: '0 learned', action: 'startFlashcards', target: 'hsk6' },
                    { icon: '⏫', text: 'HSK 7-9', value: '0 learned', action: 'startFlashcards', target: 'hsk789' }
                ]
            },
            progress: {
                title: 'PROGRESS',
                breadcrumb: 'HOME > STATS > PROGRESS',
                items: [
                    { icon: '1️⃣', text: 'HSK 1', value: '0 learned', action: 'viewStats', target: 'progress-hsk1' },
                    { icon: '2️⃣', text: 'HSK 2', value: '0 learned', action: 'viewStats', target: 'progress-hsk2' },
                    { icon: '3️⃣', text: 'HSK 3', value: '0 learned', action: 'viewStats', target: 'progress-hsk3' },
                    { icon: '4️⃣', text: 'HSK 4', value: '0 learned', action: 'viewStats', target: 'progress-hsk4' },
                    { icon: '5️⃣', text: 'HSK 5', value: '0 learned', action: 'viewStats', target: 'progress-hsk5' },
                    { icon: '6️⃣', text: 'HSK 6', value: '0 learned', action: 'viewStats', target: 'progress-hsk6' },
                    { icon: '⏫', text: 'HSK 7-9', value: '0 learned', action: 'viewStats', target: 'progress-hsk789' }
                ]
            },
            browse: {
                title: 'BROWSE',
                breadcrumb: 'HOME > STATS > BROWSE',
                items: [
                    { icon: '1️⃣', text: 'HSK 1', value: '0 total', action: 'viewStats', target: 'allcards-hsk1' },
                    { icon: '2️⃣', text: 'HSK 2', value: '0 total', action: 'viewStats', target: 'allcards-hsk2' },
                    { icon: '3️⃣', text: 'HSK 3', value: '0 total', action: 'viewStats', target: 'allcards-hsk3' },
                    { icon: '4️⃣', text: 'HSK 4', value: '0 total', action: 'viewStats', target: 'allcards-hsk4' },
                    { icon: '5️⃣', text: 'HSK 5', value: '0 total', action: 'viewStats', target: 'allcards-hsk5' },
                    { icon: '6️⃣', text: 'HSK 6', value: '0 total', action: 'viewStats', target: 'allcards-hsk6' },
                    { icon: '⏫', text: 'HSK 7-9', value: '0 total', action: 'viewStats', target: 'allcards-hsk789' }
                ]
            },
            settings: {
                title: 'SETTINGS',
                breadcrumb: 'HOME > SETTINGS',
                items: [
                    { icon: '🎨', text: 'Theme', value: 'classic', action: 'openMenu', target: 'themes' },
                    //{ icon: '🔤', text: 'Script', value: 'Simplified', action: 'toggleScript', target: null },
                    { icon: '🔊', text: 'Sound', value: `${gameState.soundEnabled ? 'On' : 'Off'}`, action: 'toggleSound', target: null },
                    { icon: '📖', text: 'User Manual', value: 'How to play', action: 'showUserManual', target: null },
                    //{ icon: '🌙', text: 'Sleep Mode', value: '22:00', action: 'setSleepTime', target: null },
                    { icon: '🔄', text: 'Reset Pet', value: 'Start Over', action: 'confirmReset', target: null }
                ]
            },
            themes: {
                title: 'SELECT THEME',
                breadcrumb: 'HOME > SETTINGS > THEME',
                items: [
                    { icon: '🟫', text: 'Classic', value: 'Default theme', action: 'selectTheme', target: 'classic' },
                    { icon: '🌸', text: 'Sakura', value: 'Pink blossom', action: 'selectTheme', target: 'sakura' },
                    { icon: '🐉', text: 'Dragon', value: 'Red & black', action: 'selectTheme', target: 'dragon' },
                    { icon: '🌙', text: 'Midnight', value: 'Dark blue', action: 'selectTheme', target: 'midnight' },
                    { icon: '🌊', text: 'Ocean', value: 'Deep Sea', action: 'selectTheme', target: 'ocean' },
                    { icon: '🍬', text: 'Candy', value: 'Sweet & colorful', action: 'selectTheme', target: 'candy' },
                ]
            },
            confirmReset: {
                title: 'RESET SAVE DATA',
                breadcrumb: 'HOME > SETTINGS > RESET',
                items: [
                    { icon: '⚠️', text: 'Warning!', value: 'This will delete all progress', action: 'none', target: null },
                    { icon: '📚', text: 'All learned characters', value: 'Will be lost', action: 'none', target: null },
                    { icon: '📊', text: 'All scores & stats', value: 'Will be reset', action: 'none', target: null },
                    { icon: '🗑️', text: 'CONFIRM RESET', value: 'Delete everything', action: 'resetPet', target: null },
                ]
            },
            confirmReset: {
                title: 'RESET PET',
                breadcrumb: 'HOME > SETTINGS > RESET',
                items: [
                    { icon: '❗', text: 'Confirm Reset', value: 'All data will be lost!', action: 'resetPet', target: null },
                ]
            }
        };

        function updateFeedMenuCounts() {
            // Check if pet can learn new characters
            const canLearn = canLearnNewCharacters();
            
            if (!canLearn) {
                // Pet is too full or tired - show appropriate message
                if (gameState.fullness >= 5) {
                    for(let i = 0; i < menus.feed.items.length; i++) {
                        menus.feed.items[i].value = 'Too full!';
                    }
                } else if (gameState.energy <= 0) {
                    for(let i = 0; i < menus.feed.items.length; i++) {
                        menus.feed.items[i].value = 'Too tired!';
                    }
                }
                return;
            }
            
            // Update HSK 1 count (excluding both learned and skipped)
            const hsk1Available = getAvailableCharacters('hsk1').length;
            const hsk1Skipped = gameState.skippedCharacters.filter(char => {
                return characterSets.hsk1 && characterSets.hsk1.some(c => c.hanzi === char.hanzi);
            }).length;
            menus.feed.items[0].value = hsk1Available > 0 ? `${hsk1Available} new words` : 
                (hsk1Skipped > 0 ? `All learned/skipped` : 'All learned!');
            
            // Update HSK 2 count
            const hsk2Available = getAvailableCharacters('hsk2').length;
            const hsk2Skipped = gameState.skippedCharacters.filter(char => {
                return characterSets.hsk2 && characterSets.hsk2.some(c => c.hanzi === char.hanzi);
            }).length;
            menus.feed.items[1].value = hsk2Available > 0 ? `${hsk2Available} new words` : 
                (hsk2Skipped > 0 ? `All learned/skipped` : 'All learned!');

            // Update HSK 3 count
            const hsk3Available = getAvailableCharacters('hsk3').length;
            const hsk3Skipped = gameState.skippedCharacters.filter(char => {
                return characterSets.hsk3 && characterSets.hsk3.some(c => c.hanzi === char.hanzi);
            }).length;
            menus.feed.items[2].value = hsk3Available > 0 ? `${hsk3Available} new words` : 
                (hsk3Skipped > 0 ? `All learned/skipped` : 'All learned!');

            // Update HSK 4 count
            const hsk4Available = getAvailableCharacters('hsk4').length;
            const hsk4Skipped = gameState.skippedCharacters.filter(char => {
                return characterSets.hsk4 && characterSets.hsk4.some(c => c.hanzi === char.hanzi);
            }).length;
            menus.feed.items[3].value = hsk4Available > 0 ? `${hsk4Available} new words` : 
                (hsk4Skipped > 0 ? `All learned/skipped` : 'All learned!');

            // Update HSK 5 count
            const hsk5Available = getAvailableCharacters('hsk5').length;
            const hsk5Skipped = gameState.skippedCharacters.filter(char => {
                return characterSets.hsk5 && characterSets.hsk5.some(c => c.hanzi === char.hanzi);
            }).length;
            menus.feed.items[4].value = hsk5Available > 0 ? `${hsk5Available} new words` : 
                (hsk5Skipped > 0 ? `All learned/skipped` : 'All learned!');
            
            // Update HSK 6 count
            const hsk6Available = getAvailableCharacters('hsk6').length;
            const hsk6Skipped = gameState.skippedCharacters.filter(char => {
                return characterSets.hsk6 && characterSets.hsk6.some(c => c.hanzi === char.hanzi);
            }).length;
            menus.feed.items[5].value = hsk6Available > 0 ? `${hsk6Available} new words` : 
                (hsk6Skipped > 0 ? `All learned/skipped` : 'All learned!');

            // Update HSK 7-9 count
            const hsk789Available = getAvailableCharacters('hsk789').length;
            const hsk789Skipped = gameState.skippedCharacters.filter(char => {
                return characterSets.hsk789 && characterSets.hsk789.some(c => c.hanzi === char.hanzi);
            }).length;
            menus.feed.items[6].value = hsk789Available > 0 ? `${hsk789Available} new words` : 
                (hsk789Skipped > 0 ? `All learned/skipped` : 'All learned!');
        }

        function updateStatsMenuCounts() {
            // Update learned characters count
            menus.stats.items[0].value = `${gameState.learnedCharacters.length} words learned`;
            menus.stats.items[1].value = gameState.learnedCharacters.length > 0 ? 'Browse & Scores' : 'No cards yet';
            
            // Update streak count
            menus.stats.items[2].value = `${gameState.streakData.currentStreak} days`;
        }

        function updateSettingsMenuValues() {
            // Update current theme in settings menu
            menus.settings.items[0].value = gameState.currentTheme.charAt(0).toUpperCase() + gameState.currentTheme.slice(1);
        }

        function updatePlayMenuValues() {
            // Update game availability based on pet progress
            const canPlayGames = gameState.totalFeedings >= 5;
            menus.play.items[0].value = canPlayGames ? 'Pop Bubbles' : `Need ${5 - gameState.totalFeedings} more`;
            
            // Update memory game availability based on learned characters
            const canPlayMemory = gameState.learnedCharacters.length >= 5;
            menus.play.items[1].value = canPlayMemory ? 'Match Pairs' : `Study ${5 - gameState.learnedCharacters.length} more words`;
        }

        function updateStudyMenuCounts() {
            // Update learned character counts for each HSK level in study menu
            menus.study.items[0].value = `${gameState.learnedCharacters.length} learned`;
            
            const hskLevels = ['hsk1', 'hsk2', 'hsk3', 'hsk4', 'hsk5', 'hsk6', 'hsk789'];
            hskLevels.forEach((level, index) => {
                const learnedCount = gameState.learnedCharacters.filter(char => {
                    for (const [setLevel, characters] of Object.entries(characterSets)) {
                        if (setLevel === level && characters.some(c => c.hanzi === char.hanzi)) {
                            return true;
                        }
                    }
                    return false;
                }).length;
                
                menus.study.items[index].value = `${learnedCount} learned`;
            });
        }

        function updateProgressMenuCounts() {
            // Update learned character counts for progress menu
            menus.progress.items[0].value = `${gameState.learnedCharacters.length} chars learned`;
            
            const hskLevels = ['hsk1', 'hsk2', 'hsk3', 'hsk4', 'hsk5', 'hsk6', 'hsk789'];
            hskLevels.forEach((level, index) => {
                const learnedCount = gameState.learnedCharacters.filter(char => {
                    for (const [setLevel, characters] of Object.entries(characterSets)) {
                        if (setLevel === level && characters.some(c => c.hanzi === char.hanzi)) {
                            return true;
                        }
                    }
                    return false;
                }).length;
                
                menus.progress.items[index].value = `${learnedCount} learned`;
            });
        }

        function updateBrowseMenuCounts() {
            // Update total character counts for browse menu
            const allChars = getAllCharacters();
            menus.browse.items[0].value = `${allChars.length} characters`;
            
            const hskLevels = ['hsk1', 'hsk2', 'hsk3', 'hsk4', 'hsk5', 'hsk6', 'hsk789'];
            hskLevels.forEach((level, index) => {
                const levelChars = characterSets[level] || [];
                menus.browse.items[index].value = `${levelChars.length} total`;
            });
        }

        // Navigation functions
        function showView(viewName) {
            // Hide all views
            document.getElementById('mainDisplay').style.display = viewName === 'main' ? 'flex' : 'none';
            document.getElementById('menuContainer').style.display = viewName === 'menu' ? 'flex' : 'none';
            document.getElementById('learningContainer').style.display = viewName === 'learning' ? 'flex' : 'none';
            document.getElementById('feedContainer').style.display = viewName === 'feed' ? 'flex' : 'none';
            document.getElementById('flashcardContainer').style.display = viewName === 'flashcard' ? 'flex' : 'none';
            document.getElementById('statsContainer').style.display = viewName === 'stats' ? 'flex' : 'none';
            document.getElementById('userManualContainer').style.display = viewName === 'userManual' ? 'flex' : 'none';
            document.getElementById('pinyinPopContainer').style.display = viewName === 'pinyinPop' ? 'flex' : 'none';
            document.getElementById('memoryGameContainer').style.display = viewName === 'memoryGame' ? 'flex' : 'none';
            document.getElementById('pomodoroContainer').style.display = viewName === 'pomodoro' ? 'flex' : 'none';
            document.getElementById('sleepContainer').style.display = viewName === 'sleep' ? 'flex' : 'none';
            
            // Update pet state when showing main view
            if (viewName === 'main') {
                updatePetState();
            }
            
            // Update bottom hint
            const bottomHint = document.getElementById('bottomHint');
            switch(viewName) {
                case 'main':
                    bottomHint.textContent = 'Press B to enter menu';
                    bottomHint.style.display = 'block';
                    break;
                case 'menu':
                case 'learning':
                case 'feed':
                case 'flashcard':
                case 'stats':
                case 'userManual':
                case 'pinyinPop':
                case 'memoryGame':
                case 'pomodoro':
                case 'sleep':
                    bottomHint.style.display = 'none';
                    break;
            }
            
            gameState.currentView = viewName;
        }

        function renderMenu(menuName) {
            const menu = menus[menuName];
            if (!menu) return;

            // Update dynamic values before rendering
            updateFeedMenuCounts();
            updateStatsMenuCounts();
            updateSettingsMenuValues();
            updatePlayMenuValues();
            updateStudyMenuCounts();
            updateProgressMenuCounts();
            updateBrowseMenuCounts();

            document.getElementById('menuTitle').textContent = menu.title;
            document.getElementById('menuBreadcrumb').textContent = menu.breadcrumb;
            
            const menuContent = document.getElementById('menuContent');
            menuContent.innerHTML = '';
            
            menu.items.forEach((item, index) => {
                const menuItem = document.createElement('div');
                menuItem.className = `menu-item ${index === gameState.selectedMenuItem ? 'selected' : ''}`;
                menuItem.innerHTML = `
                    <div class="menu-item-icon">${item.icon}</div>
                    <div class="menu-item-text">${item.text}</div>
                    <div class="menu-item-value">${item.value}</div>
                `;
                menuContent.appendChild(menuItem);
            });
            
            gameState.currentMenu = menuName;
        }

        function navigateMenu(direction) {
            const menu = menus[gameState.currentMenu];
            if (!menu) return;
            
            if (direction === 'up') {
                gameState.selectedMenuItem = (gameState.selectedMenuItem - 1 + menu.items.length) % menu.items.length;
            } else if (direction === 'down') {
                gameState.selectedMenuItem = (gameState.selectedMenuItem + 1) % menu.items.length;
            }
            
            renderMenu(gameState.currentMenu);
        }

        function selectMenuItem() {
            const menu = menus[gameState.currentMenu];
            if (!menu) return;
            
            const selectedItem = menu.items[gameState.selectedMenuItem];
            if (!selectedItem) return;
            
            switch(selectedItem.action) {
                case 'openMenu':
                    gameState.menuHistory.push({ menu: gameState.currentMenu, selectedItem: gameState.selectedMenuItem });
                    gameState.selectedMenuItem = 0;
                    renderMenu(selectedItem.target);
                    break;
                case 'goBack':
                    goBackInMenu();
                    break;
                case 'startLearning':
                    startLearningSession();
                    break;
                case 'startFeeding':
                    // Check if pet can learn (not too full and has energy)
                    if (!canLearnNewCharacters()) {
                        if (gameState.fullness >= 5) {
                            console.log('Your pet is too full! Study some flashcards first to make room.');
                        } else if (gameState.energy <= 0) {
                            console.log('Your pet is too tired! Let them sleep first.');
                        }
                        return;
                    }
                    
                    const availableChars = getAvailableCharacters(selectedItem.target);
                    if (availableChars.length === 0) {
                        console.log('No new characters available in this set!');
                        return;
                    }
                    startFeedingSession(selectedItem.target);
                    break;
                case 'startFlashcards':
                    if(Math.floor(gameState.energy) > 0) {
                        startFlashcardSession(selectedItem.target);
                    } else {
                        showFatigueWarning();
                    }
                    break;
                case 'startGame':
                    if (selectedItem.target === 'speed') {
                        if (gameState.totalFeedings >= 5) {
                            startPinyinPopGame();
                        } else {
                            console.log(`Your pet needs to grow more! Feed ${5 - gameState.totalFeedings} more characters first.`);
                        }
                    } else if (selectedItem.target === 'memory') {
                        if (gameState.learnedCharacters.length >= 5) {
                            startMemoryGame();
                        } else {
                            console.log(`Study at least ${5 - gameState.learnedCharacters.length} more words to unlock Memory Game!`);
                        }
                    } else if (selectedItem.target === 'pomodoro') {
                        startPomodoroTimer();
                    } else {
                        console.log(`Game not implemented: ${selectedItem.target}`);
                    }
                    break;
                case 'viewStats':
                    if (selectedItem.target === 'allcards') {
                        showAllCharactersView();
                    } else if (selectedItem.target === 'progress') {
                        showProgressView();
                    } else if (selectedItem.target === 'streak') {
                        showStreakView();
                    } else if (selectedItem.target.startsWith('progress-')) {
                        const hskLevel = selectedItem.target.replace('progress-', '');
                        showProgressView(hskLevel);
                    } else if (selectedItem.target.startsWith('allcards-')) {
                        const hskLevel = selectedItem.target.replace('allcards-', '');
                        showAllCharactersView(hskLevel);
                    } else {
                        console.log(`Viewing stats: ${selectedItem.target}`);
                    }
                    break;
                case 'selectTheme':
                    applyTheme(selectedItem.target);
                    updateSettingsMenuValues();
                    renderMenu(gameState.currentMenu);
                    break;
                case 'toggleThemes':
                    toggleThemeSelector();
                    break;
                case 'sleep':
                    performSleep();
                    break;
                case 'confirmReset':
                    confirmResetPet();
                    break;
                case 'resetPet':
                    resetPetData();
                    break;
                case 'toggleSound':
                    gameState.soundEnabled = !gameState.soundEnabled;
                    console.log(`Sound is now ${gameState.soundEnabled ? 'enabled' : 'disabled'}`);
                    selectedItem.value = gameState.soundEnabled ? 'On' : 'Off';
                    saveSound();
                    renderMenu(gameState.currentMenu);
                    break;
                case 'showUserManual':
                    showUserManual();
                    break;
                case 'none':
                    // Do nothing - for display-only menu items
                    break;
                case 'comingSoon':
                    console.log('Feature coming soon!');
                    break;
                default:
                    console.log(`Action: ${selectedItem.action}, Target: ${selectedItem.target}`);
                    break;
            }
        }

        function showProgressView(hskLevel = 'all') {
            gameState.statsView.viewMode = 'progress';
            gameState.statsView.hskLevel = hskLevel;
            gameState.statsView.scrollIndex = 0;
            if (gameState.learnedCharacters.length === 0) {
                console.log('No characters learned yet!');
                return;
            }
            showView('stats');
            renderStatsView();
        }

        function showAllCharactersView(hskLevel = 'all') {
            gameState.statsView.viewMode = 'allcards';
            gameState.statsView.hskLevel = hskLevel;
            gameState.statsView.scrollIndex = 0;
            showView('stats');
            renderStatsView();
        }

        function showStreakView() {
            gameState.statsView.viewMode = 'streak';
            gameState.statsView.scrollIndex = 0;
            showView('stats');
            renderStreakView();
        }

        function showUserManual() {
            gameState.userManualView.scrollIndex = 0;
            showView('userManual');
            renderUserManualView();
        }

        function renderUserManualView() {
            
        }

        function scrollUserManual(direction) {
            const statsContent = document.getElementById('userManualContent');
            const scrollAmount = 60; // pixels to scroll per press

            if (direction === 'up') {
                statsContent.scrollTop = Math.max(0, statsContent.scrollTop - scrollAmount);
            } else if (direction === 'down') {
                statsContent.scrollTop = Math.min(statsContent.scrollHeight, statsContent.scrollTop + scrollAmount);
            }
        }

        function getAllCharacters() {
            const allChars = [];
            Object.values(characterSets).forEach(set => {
                allChars.push(...set);
            });
            return allChars;
        }

        function renderStatsView() {
            if (gameState.statsView.viewMode === 'streak') {
                renderStreakView();
                return;
            }
            
            const statsContent = document.getElementById('statsContent');
            const hskLevel = gameState.statsView.hskLevel || 'all';
            let charactersToShow = [];
            
            if (gameState.statsView.viewMode === 'progress') {
                let learnedChars = [...gameState.learnedCharacters];
                
                // Filter by HSK level if specified
                if (hskLevel !== 'all') {
                    learnedChars = learnedChars.filter(char => {
                        for (const [level, characters] of Object.entries(characterSets)) {
                            if (characters.some(c => c.hanzi === char.hanzi)) {
                                return level === hskLevel;
                            }
                        }
                        return false;
                    });
                }
                
                charactersToShow = sortCharactersByScore(learnedChars);
                document.getElementById('statsTitle').textContent = 'PROGRESS';
                const levelText = hskLevel === 'all' ? 'ALL' : hskLevel.toUpperCase();
                document.getElementById('statsBreadcrumb').textContent = `${levelText} - ${charactersToShow.length} LEARNED`;
            } else {
                if (hskLevel === 'all') {
                    charactersToShow = getAllCharacters();
                } else {
                    charactersToShow = characterSets[hskLevel] || [];
                }
                
                document.getElementById('statsTitle').textContent = 'ALL CARDS';
                const levelText = hskLevel === 'all' ? 'ALL' : hskLevel.toUpperCase();
                document.getElementById('statsBreadcrumb').textContent = `${levelText} - ${charactersToShow.length} TOTAL`;
            }
            
            if (charactersToShow.length === 0) {
                statsContent.innerHTML = `
                    <div class="empty-state">
                        <div>🈳</div>
                        <div>No characters available!</div>
                        <div>Something went wrong.</div>
                    </div>
                `;
                return;
            }
            
            statsContent.innerHTML = '';
            
            charactersToShow.forEach((character, index) => {
                const characterCard = document.createElement('div');
                characterCard.className = 'character-card';
                
                // Check if this character is learned
                const learnedChar = gameState.learnedCharacters.find(c => c.hanzi === character.hanzi);
                const isLearned = !!learnedChar;
                
                let scoreDisplay = '';
                if (gameState.statsView.viewMode === 'progress') {
                    // Progress view - show success rate and attempts for learned characters
                    const score = learnedChar.score || 0;
                    const timesSeen = learnedChar.timesSeen || 0;
                    const successRate = timesSeen > 0 ? (score / timesSeen * 100).toFixed(1) : 0;
                    
                    scoreDisplay = `
                        <div class="character-score">
                            <div class="score-display">${successRate}% (${score}/${timesSeen})</div>
                        </div>
                    `;
                } else {
                    // All cards view - show learned status and success rate if learned
                    if (isLearned) {
                        const score = learnedChar.score || 0;
                        const timesSeen = learnedChar.timesSeen || 0;
                        if (timesSeen > 0) {
                            const successRate = (score / timesSeen * 100).toFixed(1);
                            scoreDisplay = `
                                <div class="character-score">
                                    <div class="score-display">${successRate}% (${score}/${timesSeen})</div>
                                </div>
                            `;
                        } else {
                            scoreDisplay = `
                                <div class="character-score">
                                    <div class="score-display">Not Studied</div>
                                    <div class="score-details"></div>
                                </div>
                            `;
                        }
                    } else {
                        scoreDisplay = `
                            <div class="character-score">
                                <div class="score-display">Needs Fed</div>
                                <div class="score-details"></div>
                            </div>
                        `;
                    }
                }
                
                characterCard.innerHTML = `
                    <div class="character-info">
                        <div class="character-hanzi">${character.hanzi}</div>
                        <div class="character-details">
                            <div class="character-pinyin">${character.pinyin}</div>
                            <div class="character-english">${character.english}</div>
                        </div>
                    </div>
                    ${scoreDisplay}
                `;
                
                // Add different styling for unlearned characters in all cards view
                if (gameState.statsView.viewMode === 'allcards' && !isLearned) {
                    characterCard.style.opacity = '0.6';
                }
                
                statsContent.appendChild(characterCard);
            });
        }

        function renderStreakView() {
            const statsContent = document.getElementById('statsContent');
            
            document.getElementById('statsTitle').textContent = 'STREAK';
            document.getElementById('statsBreadcrumb').textContent = `DAY ${gameState.streakData.currentStreak}`;
            
            const today = new Date();
            const todayDateString = today.toLocaleDateString();
            
            // Calculate days since last play
            let daysSinceLastPlay = 0;
            if (gameState.streakData.lastPlayDate) {
                const lastPlayDate = new Date(gameState.streakData.lastPlayDate);
                const timeDiff = today.getTime() - lastPlayDate.getTime();
                daysSinceLastPlay = Math.floor(timeDiff / (1000 * 3600 * 24));
            }
            
            statsContent.innerHTML = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 16px;">🔥</div>
                    <div style="font-size: 24px; color: var(--screen-color); margin-bottom: 8px;">
                        ${gameState.streakData.currentStreak} Day${gameState.streakData.currentStreak !== 1 ? 's' : ''}
                    </div>
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 24px;">Current Streak</div>
                    
                    <div style="display: flex; justify-content: space-between; margin-bottom: 16px; padding: 12px; background: rgba(0, 184, 148, 0.1); border-radius: 6px;">
                        <div style="text-align: center;">
                            <div style="font-size: 16px; color: var(--screen-color);">${gameState.streakData.longestStreak}</div>
                            <div style="font-size: 10px; opacity: 0.7;">Best Streak</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 16px; color: var(--screen-color);">${todayDateString}</div>
                            <div style="font-size: 10px; opacity: 0.7;">Today</div>
                        </div>
                    </div>
                    
                    ${daysSinceLastPlay === 0 ? 
                        '<div style="font-size: 12px; color: #4CAF50;">✓ Played today!</div>' :
                        daysSinceLastPlay === 1 ?
                        '<div style="font-size: 12px; color: #FF9800;">Keep it up! Play today to continue your streak.</div>' :
                        '<div style="font-size: 12px; color: #F44336;">Streak broken! Start a new one by playing today.</div>'
                    }
                    
                    <div style="margin-top: 24px; font-size: 10px; opacity: 0.6;">
                        ${gameState.streakData.lastPlayDate ? 
                            `Last played: ${new Date(gameState.streakData.lastPlayDate).toLocaleDateString()}` : 
                            'Welcome! Start your first streak today.'
                        }
                    </div>
                </div>
            `;
        }

        function scrollStatsView(direction) {
            const statsContent = document.getElementById('statsContent');
            const scrollAmount = 60; // Amount to scroll each time
            
            if (direction === 'up') {
                statsContent.scrollTop -= scrollAmount;
            } else if (direction === 'down') {
                statsContent.scrollTop += scrollAmount;
            }
        }

        function goBackInMenu() {
            if (gameState.menuHistory.length > 0) {
                const previous = gameState.menuHistory.pop();
                gameState.selectedMenuItem = previous.selectedItem;
                renderMenu(previous.menu);
            } else {
                // Go back to main view
                showView('main');
                gameState.selectedMenuItem = 0;
            }
        }

        function startLearningSession() {
            gameState.learningSession.currentIndex = 0;
            showView('learning');
            updateLearningDisplay();
        }

        function updateLearningDisplay() {
            const session = gameState.learningSession;
            const character = session.characters[session.currentIndex];
            
            document.getElementById('hanziDisplay').textContent = character.hanzi;
            document.getElementById('pinyinDisplay').textContent = character.pinyin;
            document.getElementById('englishDisplay').textContent = character.english;
            document.getElementById('learningProgress').textContent = `${session.currentIndex + 1}/${session.characters.length}`;
        }

        function navigateLearning(direction) {
            const session = gameState.learningSession;
            
            if (direction === 'next' && session.currentIndex < session.characters.length - 1) {
                session.currentIndex++;
                updateLearningDisplay();
            } else if (direction === 'prev' && session.currentIndex > 0) {
                session.currentIndex--;
                updateLearningDisplay();
            } else if (direction === 'next' && session.currentIndex === session.characters.length - 1) {
                // Completed session
                completeLearningSession();
            }
        }

        function completeLearningSession() {
            // Update stats
            gameState.happiness = Math.min(5, gameState.happiness + 1);
            updateStatusBars();
            
            // Return to main view
            showView('main');
        }

        function performSleep() {
            // Start the sleep session
            startSleep();
        }

        // === SLEEP SYSTEM ===
        function startSleep() {
            gameState.sleepState.isSleeping = true;
            gameState.sleepState.sleepStartTime = Date.now();
            
            // Show sleep view
            showView('sleep');
            updateSleepDisplay();
            
            // Start the sleep timer - restore 1 energy per minute
            gameState.sleepState.sleepTimer = setInterval(() => {
                if (gameState.energy < 5) {
                    gameState.energy++;
                    updateStatusBars();
                    updateSleepDisplay();
                    savePetStats(); // Save progress
                    
                    // Check if we've reached max energy
                    if (gameState.energy >= 5) {
                        // Sleep complete, wake up naturally
                        gameState.energy = 5;
                        completeSleep();
                    }
                }
            }, 60000); // 1 minute
        }

        function updateSleepDisplay() {
            // Update sleep pet emoji
            const sleepPet = document.getElementById('sleepPet');
            const sleepMessage = document.getElementById('sleepMessage');
            const sleepStats = document.getElementById('sleepStats');
            const sleepProgressBar = document.getElementById('sleepProgressBar');
            
            // Show current pet with sleeping animation
            sleepPet.style.backgroundImage = `url('${getCurrentPetImage()}')`;
            sleepPet.textContent = ''; // Clear any text content
            
            // Update message based on progress
            const progress = Math.floor(gameState.energy) / 5;
            if (progress >= 1) {
                sleepMessage.textContent = '🌅 Fully rested and energized!';
            } else if (progress >= 0.8) {
                sleepMessage.textContent = '😊 Almost fully rested...';
            } else if (progress >= 0.6) {
                sleepMessage.textContent = '😌 Feeling much better...';
            } else if (progress >= 0.4) {
                sleepMessage.textContent = '😴 Deep sleep restoring energy...';
            } else {
                sleepMessage.textContent = '💤 Sleeping peacefully...';
            }
            
            // Update progress bar
            sleepProgressBar.style.width = (progress * 100) + '%';
            
            // Update stats
            sleepStats.textContent = `Energy: ${Math.floor(gameState.energy)}/5`;
        }

        function interruptSleep() {
            if (!gameState.sleepState.isSleeping) return;
            
            // Clear the sleep timer
            if (gameState.sleepState.sleepTimer) {
                clearInterval(gameState.sleepState.sleepTimer);
                gameState.sleepState.sleepTimer = null;
            }
            
            // 50% chance to reduce happiness when interrupted
            if (Math.random() < 0.5) {
                gameState.happiness = Math.max(0, gameState.happiness - 1);
                updateStatusBars();
                savePetStats(); // Save updated stats
                
                // Show a brief message about being cranky
                setTimeout(() => {
                    alert('😤 Your pet is a bit cranky from being woken up!');
                }, 100);
            }
            
            // End sleep state
            gameState.sleepState.isSleeping = false;
            gameState.sleepState.sleepStartTime = null;
            
            // Return to main view
            showView('main');
        }

        function completeSleep() {
            if (!gameState.sleepState.isSleeping) return;
            
            // Clear the sleep timer
            if (gameState.sleepState.sleepTimer) {
                clearInterval(gameState.sleepState.sleepTimer);
                gameState.sleepState.sleepTimer = null;
            }
            
            // End sleep state
            gameState.sleepState.isSleeping = false;
            gameState.sleepState.sleepStartTime = null;
            
            // Show completion message briefly
            setTimeout(() => {
                alert('🌅 Your pet woke up fully rested!');
                showView('main');
            }, 1000);
        }

        // === FEEDING SYSTEM ===
        function startFeedingSession(characterSet) {
            // Double-check if pet can learn (safety check)
            if (!canLearnNewCharacters()) {
                console.log('Pet cannot learn right now!');
                return;
            }
            
            const availableChars = getAvailableCharacters(characterSet);
            
            if (availableChars.length === 0) {
                console.log('No new characters available in this set!');
                return;
            }

            // Pick up to 10 random characters
            const selectedChars = getRandomCharacters(availableChars, Math.min(10, availableChars.length));
            
            gameState.feedSession.characterSet = characterSet;
            gameState.feedSession.characters = selectedChars;
            gameState.feedSession.currentIndex = 0;
            
            // Update learning session with these characters
            gameState.learningSession.characters = selectedChars;
            gameState.learningSession.currentIndex = 0;
            
            showView('feed');
            updateFeedDisplay();
        }

        function updateFeedDisplay() {
            const session = gameState.feedSession;
            
            // Safety check for empty characters array
            if (!session.characters || session.characters.length === 0) {
                console.log('No characters to display in feed session!');
                showView('main');
                return;
            }
            
            const character = session.characters[session.currentIndex];
            
            // Safety check for current character
            if (!character) {
                console.log('No current character to display!');
                showView('main');
                return;
            }
            
            document.getElementById('feedHanziDisplay').textContent = character.hanzi;
            document.getElementById('feedPinyinDisplay').textContent = character.pinyin;
            document.getElementById('feedEnglishDisplay').textContent = character.english;
            document.getElementById('feedProgress').textContent = `${session.currentIndex + 1}/${session.characters.length}`;

            // Play TTS if sound is enabled
            if(gameState.soundEnabled) {
                playTTS(character.hanzi);
            }
            
            // Update breakdown if element exists
            const breakdown = document.getElementById('feedBreakdown');
            if (breakdown) {
                breakdown.innerHTML = `
                    <div>${character.description || 'Learning new character'}</div>
                    <div class="stroke-info">Strokes: ${character.strokes || '?'} | Radical: ${character.radical || '?'}</div>
                `;
            }
        }

        function navigateFeeding(direction) {
            const session = gameState.feedSession;
            
            if (direction === 'next') {
                // Check if pet is too full to learn
                if (!canLearnNewCharacters()) {
                    showFullnessWarning();
                    return;
                }
                
                // "Feed" the current character to the pet
                const currentChar = session.characters[session.currentIndex];
                
                // Show feeding animation
                showFeedingAnimation(currentChar);
                
                // Add character to learned list after a short delay
                setTimeout(() => {
                    addLearnedCharacter(currentChar);
                    // Increase happiness and fullness every other feeding
                    if ((gameState.totalFeedings % 2) === 0) {
                        gameState.happiness = Math.min(5, gameState.happiness + 1);
                        gameState.fullness = Math.min(5, gameState.fullness + 1);
                    }
                    updateStatusBars();
                    updatePetState();
                    
                    if (session.currentIndex < session.characters.length - 1 && gameState.fullness < 5) {
                        session.currentIndex++;
                        updateFeedDisplay();
                    } else {
                        // Completed feeding session
                        completeFeedingSession();
                    }
                }, 1600); // Wait for animation to complete
                
            } else if (direction === 'prev' && session.currentIndex > 0) {
                session.currentIndex--;
                updateFeedDisplay();
            }
        }

        function skipCurrentCharacter() {
            const session = gameState.feedSession;
            const currentChar = session.characters[session.currentIndex];
            
            // Add character to skipped list
            addSkippedCharacter(currentChar);
            
            console.log(`Skipped character: ${currentChar.hanzi}`);
            
            // Move to next character or complete session
            if (session.currentIndex < session.characters.length - 1) {
                session.currentIndex++;
                updateFeedDisplay();
            } else {
                // Completed feeding session
                completeFeedingSession();
            }
        }

        function completeFeedingSession() {
            console.log(`Fed ${gameState.feedSession.characters.length} new characters!`);
            updateFeedMenuCounts(); // Update menu counts
            showView('main');
        }

        // Feeding animation function
        function showFeedingAnimation(character) {
            const buttons = document.querySelectorAll('.button');
            buttons.forEach(btn => btn.disabled = true);
            const feedingAnimation = document.getElementById('feedingAnimation');
            const feedingCharacter = document.getElementById('feedingCharacter');
            const feedingPet = document.getElementById('feedingPet');
            const feedingText = document.querySelector('.feeding-text');
            
            // Update the character being fed
            feedingCharacter.textContent = character.hanzi;
            
            // Update pet sprite based on current evolution - find the correct evolution stage
            let currentEvolution;
            if (gameState.petStage === 'egg' || gameState.petStage === 'baby') {
                currentEvolution = evolutionData.stages[gameState.petStage];
            } else {
                // For child, teen, adult stages, combine type and stage
                const evolutionKey = gameState.petType + gameState.petStage.charAt(0).toUpperCase() + gameState.petStage.slice(1);
                currentEvolution = evolutionData.stages[evolutionKey];
            }
            feedingPet.style.backgroundImage = `url('${currentEvolution ? currentEvolution.image : 'images/pet-dragon-baby.png'}')`;
            feedingPet.textContent = ''; // Clear any text content
            
            // Update feeding text based on fullness
            const feedingMessages = [
                "Nom nom nom!",
                "Yummy! 😋",
                "Getting full! 😊",
                "Almost full! 😌",
                "So full! 😴"
            ];
            feedingText.textContent = feedingMessages[Math.min(gameState.fullness, 5)];
            
            // Show the animation
            feedingAnimation.classList.add('show');
            
            // Hide after 1.5 seconds
            setTimeout(() => {
                feedingAnimation.classList.remove('show');
                
                buttons.forEach(btn => btn.disabled = false);
            }, 1500);
        }

        // === FLASHCARD SYSTEM ===
        function startFlashcardSession(hskLevel = 'all') {
            if (gameState.learnedCharacters.length === 0) {
                console.log('Feed your pet some characters first!');
                return;
            }
            
            // Filter characters by HSK level if specified
            let charactersToStudy = [...gameState.learnedCharacters];
            if (hskLevel !== 'all') {
                charactersToStudy = gameState.learnedCharacters.filter(char => {
                    // Find which HSK level this character belongs to
                    for (const [level, characters] of Object.entries(characterSets)) {
                        if (characters.some(c => c.hanzi === char.hanzi)) {
                            return level === hskLevel;
                        }
                    }
                    return false;
                });
                
                if (charactersToStudy.length === 0) {
                    console.log(`No learned characters found for ${hskLevel.toUpperCase()}!`);
                    return;
                }
            }
            
            // Sort characters by score (lowest first)
            const sortedCharacters = sortCharactersByScore(charactersToStudy);
            
            gameState.flashcardSession.characters = sortedCharacters;
            gameState.flashcardSession.currentIndex = 0;
            gameState.flashcardSession.isFlipped = false;
            gameState.flashcardSession.stats = { correct: 0, wrong: 0, streak: 0 };
            showView('flashcard');
            updateFlashcardDisplay();
        }

        function updateFlashcardDisplay() {
            const session = gameState.flashcardSession;
            
            // Reset flip state
            session.isFlipped = false;
            const flashcard = document.getElementById('flashcard');
            flashcard.classList.remove('flipped');
            
            // Update content based on study mode
            const mode = session.mode;
            const character = session.characters[session.currentIndex];
            
            document.getElementById('flashcardProgress').textContent = `${session.currentIndex + 1}/${session.characters.length}`;
            document.getElementById('flashcardMode').textContent = mode.toUpperCase() + ' MODE';
            
            switch (mode) {
                case 'hanzi':
                    document.getElementById('flashcardQuestion').textContent = character.hanzi;
                    document.getElementById('flashcardAnswer').textContent = character.pinyin;
                    document.getElementById('flashcardAnswerSub').textContent = character.english;
                    break;
                case 'pinyin':
                    document.getElementById('flashcardQuestion').textContent = character.pinyin;
                    document.getElementById('flashcardAnswer').textContent = character.hanzi;
                    document.getElementById('flashcardAnswerSub').textContent = character.english;
                    break;
                case 'english':
                    document.getElementById('flashcardQuestion').textContent = character.english;
                    document.getElementById('flashcardAnswer').textContent = character.hanzi;
                    document.getElementById('flashcardAnswerSub').textContent = character.pinyin;
                    break;
            }
            
            // Update stats
            updateFlashcardStats();
        }

        function updateFlashcardStats() {
            const stats = gameState.flashcardSession.stats;
            document.getElementById('correctCount').textContent = stats.correct;
            document.getElementById('wrongCount').textContent = stats.wrong;
            document.getElementById('streakCount').textContent = stats.streak;
        }

        function setStudyMode(mode) {
            gameState.flashcardSession.mode = mode;
            
            // Update button states
            document.querySelectorAll('.study-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            updateFlashcardDisplay();
        }

        function flipCard() {
            const session = gameState.flashcardSession;
            const currentCharacter = session.characters[session.currentIndex];
            const flashcard = document.getElementById('flashcard');
            
            session.isFlipped = !session.isFlipped;
            if(session.isFlipped && gameState.soundEnabled) {
                playTTS(currentCharacter.hanzi);
            }

            document.getElementsByClassName('c-button')[0].textContent = session.isFlipped ? 'C: CORRECT' : 'C: BACK';
            flashcard.classList.toggle('flipped', session.isFlipped);
        }

        function answerFlashcard(isCorrect) {
            const session = gameState.flashcardSession;
            const currentCharacter = session.characters[session.currentIndex];
            
            // Update character score
            updateCharacterScore(currentCharacter.hanzi, isCorrect);
            
            // Update session stats
            if (isCorrect) {
                session.stats.correct++;
                session.stats.streak++;
                
                // Reduce fullness on correct answers (studying helps digest knowledge)
                if (session.stats.correct % 3 === 0) { // Every 3 correct answers
                    reduceFullnessFromStudy();
                }

            } else {
                session.stats.wrong++;
                session.stats.streak = 0;
                
                // Happiness penalty: Every 5 wrong answers in studying
                if (session.stats.wrong % 5 === 0) {
                    gameState.happiness = Math.max(0, gameState.happiness - 1);
                    console.log(`Happiness decreased due to ${session.stats.wrong} wrong answers in study session`);
                }
            }
            
            reduceEnergyFromStudy(); // Studying costs energy regardless of correctness
            updateStatusBars();
            updatePetState();
            
            // Move to next card
            if (session.currentIndex < session.characters.length - 1) {
                session.currentIndex++;
                
                // If the card is currently flipped, wait for the flip animation to complete
                // before updating the display to avoid revealing the new card content too early
                if (session.isFlipped) {
                    // First flip the card back to front side
                    flipCard();
                    // Then wait for the animation to complete before updating content
                    setTimeout(() => {
                        updateFlashcardDisplay();
                    }, 650); // 650ms to ensure 600ms animation completes
                } else {
                    // Card is already on front side, update immediately
                    updateFlashcardDisplay();
                }
            } else {
                // Completed flashcard session
                completeFlashcardSession();
            }
        }

        function completeFlashcardSession() {
            const stats = gameState.flashcardSession.stats;
            console.log(`Flashcard session complete! ${stats.correct}/${stats.correct + stats.wrong} correct`);
            showView('main');
        }

        // === PINYIN POP GAME ===
        function startPinyinPopGame() {
            // Check if pet is at least child level (5+ feedings)
            if (gameState.totalFeedings < 5) {
                console.log('Your pet needs to grow more before playing games! Feed at least 5 characters first.');
                return;
            }
            
            if (gameState.learnedCharacters.length === 0) {
                console.log('Feed your pet some characters first!');
                return;
            }
            
            // Reset game interface elements (in case returning from game over)
            const gameArea = document.getElementById('gameArea');
            const gameTarget = document.querySelector('.game-target');
            const gameUI = document.querySelector('.game-ui');
            
            // Show game elements
            if (gameTarget) gameTarget.style.display = 'block';
            if (gameUI) gameUI.style.display = 'block';
            
            // Clear game area content (remove any game over message)
            gameArea.innerHTML = '';
            
            // Initialize game state
            const session = gameState.pinyinPopSession;
            session.characters = sortCharactersByScore([...gameState.learnedCharacters]);
            session.bubbles = [];
            session.score = 0;
            session.lives = 3;
            session.level = 1;
            session.timeLeft = 60;
            session.gameRunning = true;
            session.stats = { correct: 0, wrong: 0, streak: 0 };
            
            showView('pinyinPop');
            updatePinyinPopDisplay();
            startPinyinPopGameLoop();
        }

        function updatePinyinPopDisplay() {
            const session = gameState.pinyinPopSession;
            
            // Update header stats
            document.getElementById('gameStats').textContent = `Score: ${session.score} | Lives: ${session.lives}`;
            document.getElementById('gameTimer').textContent = session.timeLeft;
            document.getElementById('gameLevel').textContent = session.level;
            
            // Choose a random character for the target
            if (session.characters.length > 0) {
                session.currentCharacter = session.characters[Math.floor(Math.random() * session.characters.length)];
                document.getElementById('targetPinyin').textContent = session.currentCharacter.pinyin;
                document.getElementById('targetEnglish').textContent = session.currentCharacter.english;
            }
        }

        function startPinyinPopGameLoop() {
            const session = gameState.pinyinPopSession;
            
            // Game timer
            const gameTimer = setInterval(() => {
                if (!session.gameRunning) {
                    clearInterval(gameTimer);
                    return;
                }
                
                session.timeLeft--;
                document.getElementById('gameTimer').textContent = session.timeLeft;
                
                if (session.timeLeft <= 0) {
                    console.log('DEBUG: Game ending due to time running out');
                    clearInterval(gameTimer);
                    endPinyinPopGame();
                }
            }, 1000);
            
            // Bubble spawner
            const bubbleSpawner = setInterval(() => {
                if (!session.gameRunning) {
                    clearInterval(bubbleSpawner);
                    return;
                }
                
                spawnBubble();
            }, 1500 - (session.level * 100)); // Spawn bubbles faster as level increases
        }

        function spawnBubble() {
            const session = gameState.pinyinPopSession;
            const gameArea = document.getElementById('gameArea');
            
            // Create bubble element
            const bubble = document.createElement('div');
            bubble.className = 'game-bubble';
            
            // Decide if this should be the correct character or a wrong one
            let character;
            const isCorrect = Math.random() < 0.4; // 40% chance of correct answer
            
            if (isCorrect && session.currentCharacter) {
                character = session.currentCharacter;
                bubble.dataset.correct = 'true';
                console.log(`DEBUG: Spawned CORRECT bubble: ${character.hanzi} (${character.pinyin})`);
            } else {
                // Pick a random different character
                const otherCharacters = session.characters.filter(c => c.hanzi !== session.currentCharacter?.hanzi);
                if (otherCharacters.length > 0) {
                    character = otherCharacters[Math.floor(Math.random() * otherCharacters.length)];
                } else {
                    character = session.currentCharacter; // Fallback
                }
                bubble.dataset.correct = 'false';
                console.log(`DEBUG: Spawned WRONG bubble: ${character.hanzi} (${character.pinyin})`);
            }
            
            bubble.textContent = character.hanzi;
            bubble.dataset.hanzi = character.hanzi;
            
            // Random vertical position
            const gameAreaHeight = gameArea.offsetHeight;
            const randomY = Math.random() * (gameAreaHeight - 40);
            bubble.style.top = randomY + 'px';
            bubble.style.left = '-50px';
            
            // Add click handler
            bubble.addEventListener('click', () => handleBubbleClick(bubble));
            
            gameArea.appendChild(bubble);
            session.bubbles.push(bubble);
            
            // Remove bubble after animation completes
            setTimeout(() => {
                if (bubble.parentNode && session.gameRunning) {
                    // Missed bubble - lose life if it was correct
                    if (bubble.dataset.correct === 'true') {
                        console.log(`DEBUG: Missed correct bubble ${bubble.dataset.hanzi}, losing life. Lives: ${session.lives - 1}`);
                        session.lives--;
                        session.stats.wrong++;
                        session.stats.streak = 0;
                        
                        if (session.lives <= 0) {
                            console.log('DEBUG: Game ending due to lives = 0 (missed correct bubble)');
                            showGameOver();
                            return;
                        }
                        
                        document.getElementById('gameStats').textContent = `Score: ${session.score} | Lives: ${session.lives}`;
                    } else {
                        console.log(`DEBUG: Missed wrong bubble ${bubble.dataset.hanzi}, no penalty`);
                    }
                    
                    bubble.remove();
                    const index = session.bubbles.indexOf(bubble);
                    if (index > -1) {
                        session.bubbles.splice(index, 1);
                    }
                }
            }, 3000);
        }

        function handleBubbleClick(bubble) {
            const session = gameState.pinyinPopSession;
            const isCorrect = bubble.dataset.correct === 'true';
            
            console.log(`DEBUG: Bubble clicked! Character: ${bubble.dataset.hanzi}, Marked as correct: ${bubble.dataset.correct}, IsCorrect: ${isCorrect}`);
            console.log(`DEBUG: Target character: ${session.currentCharacter?.hanzi} (${session.currentCharacter?.pinyin})`);
            
            if (isCorrect) {
                // Correct answer
                session.score += 10 * session.level;
                session.stats.correct++;
                session.stats.streak++;
                
                // Add 5 seconds for correct answer
                session.timeLeft += 5;
                document.getElementById('gameTimer').textContent = session.timeLeft;
                
                // Update character score
                updateCharacterScore(bubble.dataset.hanzi, true);
                
                // Visual feedback
                bubble.classList.add('correct');
                
                // IMPORTANT: Mark all other bubbles as incorrect since we got the correct answer
                session.bubbles.forEach(otherBubble => {
                    if (otherBubble !== bubble && otherBubble.dataset.correct === 'true') {
                        console.log(`DEBUG: Marking other correct bubble ${otherBubble.dataset.hanzi} as incorrect to prevent life loss`);
                        otherBubble.dataset.correct = 'false';
                    }
                });
                
                // Level up every 10 correct answers
                if (session.stats.correct % 10 === 0) {
                    session.level = Math.min(session.level + 1, 10); // Max level 5
                    session.timeLeft += 10; // Extra bonus time for level up
                    document.getElementById('gameTimer').textContent = session.timeLeft;
                }
                
                // Choose new target character after correct answer
                setTimeout(() => {
                    updatePinyinPopDisplay();
                }, 500);
                
            } else {
                // Wrong answer
                console.log(`DEBUG: Wrong bubble clicked! ${bubble.dataset.hanzi}. Lives before: ${session.lives}`);
                session.lives--;
                session.stats.wrong++;
                session.stats.streak = 0;
                console.log(`DEBUG: Lives after decrement: ${session.lives}`);
                
                // Update character score
                updateCharacterScore(session.currentCharacter?.hanzi, false);
                
                // Visual feedback
                bubble.classList.add('wrong');
                
                if (session.lives <= 0) {
                    console.log('DEBUG: Game ending due to lives = 0 (wrong bubble clicked)');
                    showGameOver();
                    return;
                }
            }
            
            // Update display
            document.getElementById('gameStats').textContent = `Score: ${session.score} | Lives: ${session.lives}`;
            
            // Remove bubble
            setTimeout(() => {
                bubble.remove();
                const index = session.bubbles.indexOf(bubble);
                if (index > -1) {
                    session.bubbles.splice(index, 1);
                }
            }, 500);
        }

        function showGameOver() {
            const session = gameState.pinyinPopSession;
            
            // Stop the game
            session.gameRunning = false;
            
            // Clean up all bubbles immediately
            session.bubbles.forEach(bubble => {
                if (bubble.parentNode) {
                    bubble.remove();
                }
            });
            session.bubbles = [];
            
            // Clear the game area and show game over message
            const gameArea = document.getElementById('gameArea');
            const gameTarget = document.querySelector('.game-target');
            const gameUI = document.querySelector('.game-ui');
            
            // Hide game elements
            if (gameTarget) gameTarget.style.display = 'none';
            if (gameUI) gameUI.style.display = 'none';
            
            // Create game over display
            gameArea.innerHTML = `
                <div style="
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100%;
                    text-align: center;
                    padding: 20px;
                ">
                    <div style="
                        font-size: 2rem;
                        font-weight: bold;
                        margin-bottom: 18px;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
                    ">GAME OVER</div>
                    <div style="
                        font-size: 0.8rem;
                        margin-bottom: 10px;
                        color: #555;
                    ">Final Score: ${session.score}</div>
                    <div style="
                        font-size: 0.6rem;
                        color: #777;
                        margin-bottom: 5px;
                    ">Correct: ${session.stats.correct} | Wrong: ${session.stats.wrong}</div>
                    <div style="
                        font-size: 0.6rem;
                        color: #777;
                        margin-bottom: 20px;
                    ">Level Reached: ${session.level}</div>
                    <div style="
                        font-size: 0.4rem;
                        color: #999;
                        font-style: italic;
                    ">Returning to menu...</div>
                </div>
            `;
            
            // Update pet stats based on performance and apply score-based happiness changes
            // Pinyin Pop happiness penalties/bonuses based on score when failing (lives = 0)
            if (session.score === 0) {
                gameState.happiness = Math.max(0, gameState.happiness - 2);
                console.log(`Happiness decreased by 2 due to score of 0 in Pinyin Pop`);
            } else if (session.score < 30) {
                gameState.happiness = Math.max(0, gameState.happiness - 1);
                console.log(`Happiness decreased by 1 due to low score (${session.score}) in Pinyin Pop`);
            } else if (session.score >= 100) {
                gameState.happiness = Math.min(5, gameState.happiness + 1);
                console.log(`Happiness increased by 1 due to high score (${session.score}) despite game over`);
            }
            // Score between 30-100: no happiness change
            
            gameState.energy = Math.max(0, gameState.energy - 0.2);
            updateStatusBars();
            updatePetState();
            
            console.log(`Pinyin Pop Game Over! Score: ${session.score}, Correct: ${session.stats.correct}/${session.stats.correct + session.stats.wrong}`);
            
            // Return to main menu after a short delay
            setTimeout(() => {
                showView('main');
            }, 3000);
        }

        function endPinyinPopGame() {
            const session = gameState.pinyinPopSession;
            
            // Debug: Log why the game is ending
            console.log('Game ending - Debug info:');
            console.log(`Lives: ${session.lives}`);
            console.log(`Time left: ${session.timeLeft}`);
            console.log(`Game running: ${session.gameRunning}`);
            console.log(`Score: ${session.score}`);
            console.log(`Correct answers: ${session.stats.correct}`);
            console.log(`Wrong answers: ${session.stats.wrong}`);
            
            session.gameRunning = false;
            
            // Clean up bubbles
            session.bubbles.forEach(bubble => {
                if (bubble.parentNode) {
                    bubble.remove();
                }
            });
            session.bubbles = [];
            
            // Update pet stats based on performance
            if (session.stats.correct > 0) {
                gameState.happiness = Math.min(5, gameState.happiness + 1);

                // Reduce energy from playing
                gameState.energy = Math.max(0, gameState.energy - 0.2);
                updateStatusBars();
                updatePetState();
            }
            
            console.log(`Pinyin Pop complete! Score: ${session.score}, Correct: ${session.stats.correct}/${session.stats.correct + session.stats.wrong}`);
            showView('main');
        }

        // === MEMORY GAME FUNCTIONS ===
        function startMemoryGame() {
            // Select 8 random learned characters for the memory game
            const learnedChars = [...gameState.learnedCharacters];
            const selectedChars = getRandomCharacters(learnedChars, 8);
            
            // Create tile pairs (character + pinyin for each)
            const tilePairs = [];
            selectedChars.forEach(char => {
                tilePairs.push({
                    id: `hanzi_${char.hanzi}`,
                    type: 'hanzi',
                    content: char.hanzi,
                    character: char,
                    pairId: char.hanzi
                });
                tilePairs.push({
                    id: `pinyin_${char.hanzi}`,
                    type: 'pinyin', 
                    content: char.pinyin,
                    character: char,
                    pairId: char.hanzi
                });
            });
            
            // Shuffle the tiles
            const shuffledTiles = tilePairs.sort(() => 0.5 - Math.random());
            
            // Initialize game state
            gameState.memoryGameSession = {
                gridSize: 4,
                tiles: shuffledTiles,
                flippedTiles: [],
                matchedPairs: 0,
                matchedTileIds: [],
                score: 0,
                attempts: 0,
                gameStartTime: Date.now(),
                isProcessing: false,
                characters: selectedChars,
                selectedTileIndex: 0
            };
            
            showView('memoryGame');
            renderMemoryGrid();
            updateMemoryGameUI();
        }

        function renderMemoryGrid() {
            const grid = document.getElementById('memoryGrid');
            const session = gameState.memoryGameSession;
            
            grid.innerHTML = '';
            
            session.tiles.forEach((tile, index) => {
                const tileElement = document.createElement('div');
                tileElement.className = 'memory-tile hidden';
                tileElement.id = `tile-${index}`;
                
                if (index === session.selectedTileIndex) {
                    tileElement.classList.add('selected');
                }
                
                if (session.flippedTiles.includes(index)) {
                    tileElement.classList.remove('hidden');
                    tileElement.classList.add('flipped');
                }
                
                if (isMatched(index)) {
                    tileElement.classList.remove('hidden');
                    tileElement.classList.add('matched');
                }
                
                tileElement.innerHTML = `<div class="tile-content">${tile.content}</div>`;
                grid.appendChild(tileElement);
            });
        }

        function updateMemoryGameUI() {
            const session = gameState.memoryGameSession;
            
            // Update stats
            document.getElementById('memoryGameStats').textContent = `Score: ${session.score} | Attempts: ${session.attempts}`;
            document.getElementById('memoryPairs').textContent = session.matchedPairs;
            
            // Update timer
            const elapsedTime = Math.floor((Date.now() - session.gameStartTime) / 1000);
            document.getElementById('memoryTimer').textContent = elapsedTime;
        }

        function navigateMemoryGame(direction) {
            const session = gameState.memoryGameSession;
            const gridSize = session.gridSize;
            let newIndex = session.selectedTileIndex;
            
            switch(direction) {
                case 'up':
                    newIndex = session.selectedTileIndex - gridSize;
                    if (newIndex < 0) newIndex += gridSize * gridSize;
                    break;
                case 'down':
                    newIndex = (session.selectedTileIndex + gridSize) % (gridSize * gridSize);
                    break;
                case 'left':
                    newIndex = session.selectedTileIndex - 1;
                    if (newIndex < 0) newIndex = gridSize * gridSize - 1;
                    break;
                case 'right':
                    newIndex = (session.selectedTileIndex + 1) % (gridSize * gridSize);
                    break;
            }
            
            session.selectedTileIndex = newIndex;
            renderMemoryGrid();
        }

        function flipMemoryTile() {
            const session = gameState.memoryGameSession;
            
            if (session.isProcessing) return;
            
            const tileIndex = session.selectedTileIndex;
            
            // Can't flip if already flipped or matched
            if (session.flippedTiles.includes(tileIndex) || isMatched(tileIndex)) {
                return;
            }
            
            // Can't flip more than 2 tiles at once
            if (session.flippedTiles.length >= 2) {
                return;
            }
            
            // Flip the tile
            session.flippedTiles.push(tileIndex);
            renderMemoryGrid();
            
            // Check for match if two tiles are flipped
            if (session.flippedTiles.length === 2) {
                session.isProcessing = true;
                session.attempts++;
                
                setTimeout(() => {
                    checkMemoryMatch();
                }, 1000);
            }
            
            updateMemoryGameUI();
        }

        function checkMemoryMatch() {
            const session = gameState.memoryGameSession;
            const [index1, index2] = session.flippedTiles;
            const tile1 = session.tiles[index1];
            const tile2 = session.tiles[index2];
            
            // Check if tiles match (same character, different types)
            const isMatch = tile1.character.hanzi === tile2.character.hanzi && tile1.type !== tile2.type;
            
            if (isMatch) {
                // It's a match!
                session.matchedPairs++;
                session.score += 10;
                session.matchedTileIds.push(index1, index2);
                
                // Add match animation
                const tile1Element = document.getElementById(`tile-${index1}`);
                const tile2Element = document.getElementById(`tile-${index2}`);
                tile1Element.classList.add('match-animation');
                tile2Element.classList.add('match-animation');

                if(gameState.soundEnabled) {
                    playTTS(tile1.character.hanzi);
                }
                
                // Show character definition overlay
                showCharacterDefinition(tile1.character);
                
                // Check if game is complete
                if (session.matchedPairs === 8) {
                    setTimeout(() => {
                        endMemoryGame(true);
                    }, 2000);
                }
            } else {
                // Not a match, hide tiles again
                setTimeout(() => {
                    session.flippedTiles = [];
                    renderMemoryGrid();
                    session.isProcessing = false;
                }, 500);
                return;
            }
            
            session.flippedTiles = [];
            session.isProcessing = false;
            renderMemoryGrid();
            updateMemoryGameUI();
        }

        function showCharacterDefinition(character) {
            // Create overlay similar to feeding animation
            const overlay = document.createElement('div');
            overlay.className = 'feeding-animation show';
            overlay.innerHTML = `
                <div class="feeding-character">${character.hanzi}</div>
                <div class="feeding-text">${character.pinyin}</div>
                <div class="feeding-text" style="width: 80%; text-align: center;">${character.english}</div>
            `;
            
            document.querySelector('.screen').appendChild(overlay);
            
            // Remove overlay after 1.5 seconds
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.remove();
                }
            }, 1500);
        }

        function isMatched(tileIndex) {
            const session = gameState.memoryGameSession;
            return session.matchedTileIds.includes(tileIndex);
        }

        function endMemoryGame(completed = false) {
            const session = gameState.memoryGameSession;
            
            // Calculate final score
            const elapsedTime = Math.floor((Date.now() - session.gameStartTime) / 1000);
            const timeBonus = Math.max(0, 120 - elapsedTime); // Bonus for completing quickly
            const finalScore = session.score + timeBonus;
            
            // Update pet stats based on performance
            if (completed) {
                gameState.happiness = Math.min(5, gameState.happiness + 1);
                console.log('Happiness increased by 1 for completing Memory Game!');
            }
            
            gameState.energy = Math.max(0, gameState.energy - 0.1);
            updateStatusBars();
            updatePetState();
            
            // Update streak activity (user engaged with the game)
            updateStreakActivity();
            
            console.log(`Memory Game ${completed ? 'completed' : 'ended'}! Score: ${finalScore}, Pairs: ${session.matchedPairs}/8, Time: ${elapsedTime}s`);
            
            // Show results overlay
            const overlay = document.createElement('div');
            overlay.className = 'feeding-animation show';
            overlay.innerHTML = `
                <div style="font-size: 1rem; margin-bottom: 15px; color: var(--screen-color);">${completed ? '🎉 COMPLETED!' : 'Game Over'}</div>
                <div style="font-size: 0.8rem; margin-bottom: 10px;">Pairs Matched: ${session.matchedPairs}/8</div>
                <div style="font-size: 0.8rem; margin-bottom: 10px;">Final Score: ${finalScore}</div>
                <div style="font-size: 0.8rem; margin-bottom: 10px;">Time: ${elapsedTime}s</div>
                <div style="font-size: 0.6rem; color: #777; margin-top: 15px;">Returning to menu...</div>
            `;
            
            document.querySelector('.screen').appendChild(overlay);
            
            // Return to main menu after delay
            setTimeout(() => {
                showView('main');
                if (overlay.parentNode) {
                    overlay.remove();
                }
            }, 3000);
        }

        // Pomodoro Timer Functions
        function startPomodoroTimer() {
            const session = gameState.pomodoroSession;
            
            // Initialize session
            session.isRunning = false;
            session.isPaused = false;
            session.isBreak = false;
            session.timeLeft = session.workTime;
            session.sessionsCompleted = 0;
            
            // Show pomodoro view
            showView('pomodoro');
            updatePomodoroDisplay();
        }

        function togglePomodoroTimer() {
            const session = gameState.pomodoroSession;
            
            if (!session.isRunning && !session.isPaused) {
                // Start timer
                session.isRunning = true;
                startPomodoroTick();
            } else if (session.isRunning) {
                // Pause timer
                session.isRunning = false;
                session.isPaused = true;
                if (session.timer) {
                    clearInterval(session.timer);
                    session.timer = null;
                }
            } else if (session.isPaused) {
                // Resume timer
                session.isRunning = true;
                session.isPaused = false;
                startPomodoroTick();
            }
            
            updatePomodoroDisplay();
        }

        function startPomodoroTick() {
            const session = gameState.pomodoroSession;
            
            session.timer = setInterval(() => {
                session.timeLeft--;
                updatePomodoroDisplay();
                
                if (session.timeLeft <= 0) {
                    // Time's up!
                    clearInterval(session.timer);
                    session.timer = null;
                    session.isRunning = false;
                    
                    if (!session.isBreak) {
                        // Work session completed, start break
                        session.sessionsCompleted++;
                        session.isBreak = true;
                        session.timeLeft = session.breakTime;
                        showPomodoroNotification('Work Complete!', 'Time for a break!');
                    } else {
                        // Break completed, start new work session
                        session.isBreak = false;
                        session.timeLeft = session.workTime;
                        showPomodoroNotification('Break Over!', 'Ready for next session?');
                    }
                    
                    updatePomodoroDisplay();
                }
            }, 1000);
        }

        function endPomodoroTimer() {
            const session = gameState.pomodoroSession;
            
            // Clear timer
            if (session.timer) {
                clearInterval(session.timer);
                session.timer = null;
            }
            
            // Reset session
            session.isRunning = false;
            session.isPaused = false;
            session.isBreak = false;
            session.timeLeft = session.workTime;
            
            // Show completion message if any sessions were completed
            if (session.sessionsCompleted > 0) {
                showPomodoroCompletionMessage();
            } else {
                showView('main');
            }
        }

        function updatePomodoroDisplay() {
            const session = gameState.pomodoroSession;
            
            // Update timer display
            const minutes = Math.floor(session.timeLeft / 60);
            const seconds = session.timeLeft % 60;
            const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('pomodoroTimer').textContent = timeText;
            
            // Update type display
            const typeElement = document.getElementById('pomodoroType');
            typeElement.textContent = session.isBreak ? 'BREAK TIME' : 'FOCUS TIME';
            typeElement.className = session.isBreak ? 'pomodoro-type break' : 'pomodoro-type';
            
            // Update timer color
            const timerElement = document.getElementById('pomodoroTimer');
            timerElement.className = session.isBreak ? 'pomodoro-timer break' : 'pomodoro-timer';
            
            // Update progress bar
            const totalTime = session.isBreak ? session.breakTime : session.workTime;
            const progress = ((totalTime - session.timeLeft) / totalTime) * 100;
            const progressBar = document.getElementById('pomodoroProgressBar');
            progressBar.style.width = `${progress}%`;
            progressBar.className = session.isBreak ? 'pomodoro-progress-bar break' : 'pomodoro-progress-bar';
            
            // Update status
            const statusElement = document.getElementById('pomodoroStatus');
            if (!session.isRunning && !session.isPaused) {
                statusElement.textContent = 'Press B to start';
                statusElement.className = 'pomodoro-status';
            } else if (session.isPaused) {
                statusElement.textContent = 'Paused - Press B to resume';
                statusElement.className = 'pomodoro-status pulsing';
            } else {
                statusElement.textContent = session.isBreak ? 'Take a break!' : 'Stay focused!';
                statusElement.className = 'pomodoro-status';
            }
            
            // Update sessions completed
            document.getElementById('pomodoroStats').textContent = `Sessions: ${session.sessionsCompleted}`;
        }

        function showPomodoroNotification(title, message) {
            const overlay = document.createElement('div');
            overlay.className = 'feeding-animation show';
            overlay.innerHTML = `
                <div style="font-size: 1.2rem; margin-bottom: 15px; color: var(--screen-color);">${title}</div>
                <div style="font-size: 0.9rem; margin-bottom: 20px;">${message}</div>
                <div style="font-size: 0.7rem; color: #777;">Press B to continue or C to quit</div>
            `;
            
            document.querySelector('.screen').appendChild(overlay);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.remove();
                }
            }, 3000);
        }

        function showPomodoroCompletionMessage() {
            const session = gameState.pomodoroSession;
            
            // Award happiness for completed sessions
            if (session.sessionsCompleted > 0) {
                gameState.happiness = Math.min(5, gameState.happiness + session.sessionsCompleted);
                updateStatusBars();
                updatePetState();
                updateStreakActivity();
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'feeding-animation show';
            overlay.innerHTML = `
                <div style="font-size: 1.2rem; margin-bottom: 15px; color: var(--screen-color);">🍅 Pomodoro Complete!</div>
                <div style="font-size: 0.9rem; margin-bottom: 10px;">Sessions completed: ${session.sessionsCompleted}</div>
                <div style="font-size: 0.8rem; margin-bottom: 10px;">Happiness increased!</div>
                <div style="font-size: 0.7rem; color: #777; margin-top: 15px;">Returning to menu...</div>
            `;
            
            document.querySelector('.screen').appendChild(overlay);
            
            // Return to main menu after delay
            setTimeout(() => {
                showView('main');
                if (overlay.parentNode) {
                    overlay.remove();
                }
            }, 3000);
        }

        // Reset functions
        function confirmResetPet() {
            // Simple confirmation using the in-game menu system
            gameState.menuHistory.push({ menu: gameState.currentMenu, selectedItem: gameState.selectedMenuItem });
            gameState.selectedMenuItem = 0;
            renderMenu('confirmReset');
        }

        function resetPetData() {
            // Clear all localStorage data
            localStorage.removeItem('Lingoegg_learned');
            localStorage.removeItem('Lingoegg_skipped');
            localStorage.removeItem('Lingoegg_evolution');
            localStorage.removeItem('Lingoegg_pet_stats');
            localStorage.removeItem('Lingoegg_streak');
            
            // Reset game state to initial values
            gameState.learnedCharacters = [];
            gameState.skippedCharacters = [];
            gameState.petStage = 'egg';
            gameState.petType = null;
            gameState.petName = '小龙';
            gameState.totalFeedings = 0;
            gameState.happiness = 5;
            gameState.energy = 5;
            gameState.fullness = 0;
            
            // Reset session data
            gameState.learningSession = { currentIndex: 0, characters: [] };
            gameState.feedSession = { currentIndex: 0, characterSet: 'hsk1', characters: [] };
            gameState.flashcardSession = {
                currentIndex: 0,
                mode: 'hanzi',
                isFlipped: false,
                characters: [],
                stats: { correct: 0, wrong: 0, streak: 0 }
            };
            gameState.statsView = { scrollIndex: 0, viewMode: 'progress' };
            gameState.pinyinPopSession = {
                currentPinyin: '',
                currentCharacter: null,
                bubbles: [],
                score: 0,
                lives: 3,
                level: 1,
                timeLeft: 60,
                gameRunning: false,
                characters: [],
                stats: { correct: 0, wrong: 0, streak: 0 }
            };
            gameState.memoryGameSession = {
                gridSize: 4,
                tiles: [],
                flippedTiles: [],
                matchedPairs: 0,
                matchedTileIds: [],
                score: 0,
                attempts: 0,
                gameStartTime: null,
                isProcessing: false,
                characters: []
            };
            
            // Clear happiness penalty timers
            if (gameState.happinessPenalties.fullnessTimer) {
                clearInterval(gameState.happinessPenalties.fullnessTimer);
            }
            if (gameState.happinessPenalties.energyTimer) {
                clearInterval(gameState.happinessPenalties.energyTimer);
            }
            gameState.happinessPenalties = {
                fullnessZeroSince: null,
                energyZeroSince: null,
                fullnessTimer: null,
                energyTimer: null
            };
            
            // Clear sleep timer
            if (gameState.sleepState.sleepTimer) {
                clearInterval(gameState.sleepState.sleepTimer);
            }
            gameState.sleepState = {
                isSleeping: false,
                sleepStartTime: null,
                sleepTimer: null
            };
            
            // Reset streak data
            gameState.streakData = {
                currentStreak: 0,
                lastPlayDate: null,
                longestStreak: 0
            };
            
            // Reset pet display to egg
            document.querySelector('.pet-sprite').style.backgroundImage = `url('${evolutionData.stages.egg.image}')`;
            document.querySelector('.pet-name').textContent = evolutionData.stages.egg.name;
            
            // Update UI
            updateStatusBars();
            updatePetState();
            updateFeedMenuCounts();
            updateStatsMenuCounts();
            
            console.log('Pet data reset successfully!');
            
            // Return to main view
            showView('main');
            gameState.selectedMenuItem = 0;
            gameState.menuHistory = [];
        }

        // Button press handler
        function buttonPress(button) {
            console.log(`Button ${button} pressed! Current view: ${gameState.currentView}`);
            
            // Add haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(50);
            }
            
            // Button press animation
            const buttonEl = document.querySelector(`.button-${button.toLowerCase()}`);
            buttonEl.style.transform = 'translateY(2px)';
            setTimeout(() => {
                buttonEl.style.transform = '';
            }, 100);
            
            // Handle button logic
            handleButtonPress(button);
        }

        function handleButtonPress(button) {
            switch(gameState.currentView) {
                case 'main':
                    if (button === 'B') {
                        showView('menu');
                        renderMenu('main');
                    }
                    break;
                    
                case 'menu':
                    if (button === 'A') {
                        navigateMenu('down');
                    } else if (button === 'B') {
                        selectMenuItem();
                    } else if (button === 'C') {
                        goBackInMenu();
                    }
                    break;
                    
                case 'learning':
                    if (button === 'A') {
                        navigateLearning('prev');
                    } else if (button === 'B') {
                        navigateLearning('next');
                    } else if (button === 'C') {
                        showView('main');
                    }
                    break;
                    
                case 'feed':
                    if (button === 'A') {
                        skipCurrentCharacter();
                    } else if (button === 'B') {
                        navigateFeeding('next');
                    } else if (button === 'C') {
                        showView('main');
                    }
                    break;
                    
                case 'flashcard':
                    if (button === 'A') {
                        if (gameState.flashcardSession.isFlipped) {
                            answerFlashcard(false); // Wrong
                        }
                    } else if (button === 'B') {
                        flipCard();
                    } else if (button === 'C') {
                        if (gameState.flashcardSession.isFlipped) {
                            answerFlashcard(true); // Correct
                        } else {
                            showView('main'); // Exit if not flipped
                        }
                    }
                    break;
                    
                case 'stats':
                    if (button === 'A') {
                        scrollStatsView('up');
                    } else if (button === 'B') {
                        scrollStatsView('down');
                    } else if (button === 'C') {
                        // Go back to stats menu instead of using goBackInMenu
                        showView('menu');
                        renderMenu('stats');
                    }
                    break;
                    
                case 'userManual':
                    if (button === 'A') {
                        scrollUserManual('up');
                    } else if (button === 'B') {
                        scrollUserManual('down');
                    } else if (button === 'C') {
                        // Go back to settings menu
                        showView('menu');
                        renderMenu('settings');
                    }
                    break;
                    
                case 'pinyinPop':
                    if (button === 'C') {
                        // Quit game
                        console.log('DEBUG: Game ending due to C button press (user quit)');
                        const session = gameState.pinyinPopSession;
                        session.gameRunning = false;
                        endPinyinPopGame();
                    }
                    break;
                    
                case 'memoryGame':
                    if (button === 'A') {
                        navigateMemoryGame('right');
                    } else if (button === 'B') {
                        flipMemoryTile();
                    } else if (button === 'C') {
                        endMemoryGame(false);
                    }
                    break;
                    
                case 'pomodoro':
                    if (button === 'B') {
                        togglePomodoroTimer();
                    } else if (button === 'C') {
                        endPomodoroTimer();
                    }
                    break;
                    
                case 'sleep':
                    // Any button press interrupts sleep
                    interruptSleep();
                    break;
            }
        }

        // Theme system
        const themes = {
            classic: {
                '--font-family': "'Courier New', 'monospace'",
                '--bg-color': '#1a2e',
                '--bg-pattern': 'radial-gradient(circle at 50% 50%, #16213e 0%, #1a2e 100%)',
                '--egg-color': '#f5f3e7',
                '--egg-pattern': 'linear-gradient(145deg, #f5f3e7 0%, #e8e4d0 100%)',
                '--button-a': '#ff7675',
                '--button-b': '#74b9ff',
                '--button-c': '#fdcb6e',
                '--bg-image': 'url("images/classic.png")'
            },
            sakura: {
                '--font-family': 'Comic Sans MS, cursive',
                '--bg-color': '#ffeef7',
                '--bg-pattern': 'radial-gradient(circle at 30% 70%, #ffd7e8 0%, #ffeef7 100%)',
                '--egg-color': '#ffb3d1',
                '--egg-pattern': 'linear-gradient(145deg, #ffb3d1 0%, #ff8cc8 100%)',
                '--button-a': '#ff6b9d',
                '--button-b': '#c44569',
                '--button-c': '#f8b500',
                '--bg-image': 'url("images/sakura.png")',
                '--screen-color': 'pink'
            },
            dragon: {
                '--font-family': "Times New Roman, serif",
                '--bg-color': '#0f0f0f',
                '--bg-pattern': 'radial-gradient(circle at 50% 50%, #1a0000 0%, #0f0f0f 100%)',
                '--egg-color': '#8b0000',
                '--egg-pattern': 'linear-gradient(145deg, #8b0000 0%, #660000 100%)',
                '--button-a': '#ff4444',
                '--button-b': '#ffaa00',
                '--button-c': '#44ff44',
                '--bg-image': 'url("images/dragon.png")',
                '--screen-color': 'orangered'
            },
            midnight: {
                '--font-family': "'Courier New', 'monospace'",
                '--bg-color': '#2c3e50',
                '--bg-pattern': 'radial-gradient(circle at 50% 50%, #34495e 0%, #2c3e50 100%)',
                '--egg-color': '#34495e',
                '--egg-pattern': 'linear-gradient(145deg, #34495e 0%, #2c3e50 100%)',
                '--button-a': '#3498db',
                '--button-b': '#9b59b6',
                '--button-c': '#1abc9c',
                '--bg-image': 'url("images/midnight.png")',
                '--screen-color': '#53d4c7'
            },
            ocean: {
                '--font-family': "'Courier New', 'monospace'",
                '--bg-color': '#1abc9c',
                '--bg-pattern': 'radial-gradient(circle at 50% 50%, #16a085 0%, #1abc9c 100%)',
                '--egg-color': '#16a085',
                '--egg-pattern': 'linear-gradient(145deg, #16a085 0%, #1abc9c 100%)',
                '--button-a': '#7FE8DA',
                '--button-b': '#1D767A',
                '--button-c': '#B97A57',
                '--bg-image': 'url("images/ocean.png")',
                '--screen-color': '#53d4c7'
            },
            candy: {
                    '--font-family': "'Comic Sans MS', cursive",
                    '--bg-color': '#ffcccb',
                    '--bg-pattern': 'radial-gradient(circle at 30% 70%, #ffb3b3 0%, #ffcccb 100%)',
                    '--egg-color': '#ffb3b3',
                    '--egg-pattern': 'linear-gradient(145deg, #ffb3b3 0%, #ff8c8c 100%)',
                    '--button-a': '#ff6b6b',
                    '--button-b': '#c44545',
                    '--button-c': '#f8b500',
                    '--bg-image': 'url("images/candy.png")',
                    '--screen-color': 'pink'
            }
        };

        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;
            
            const root = document.documentElement;
            
            for (const [property, value] of Object.entries(theme)) {
                root.style.setProperty(property, value);
            }
            
            
            gameState.currentTheme = themeName;
            console.log(`Applied theme: ${themeName}`);
            saveTheme();
        }

        // Update status bars
        function updateStatusBars() {
            const statusIcons = document.querySelectorAll('.status-icon');
            const stats = [gameState.happiness, gameState.energy, gameState.fullness];
            
            statusIcons.forEach((icon, index) => {
                const level = Math.floor(stats[index]); // Because energy can have decimal points.
                const bars = '▓'.repeat(level) + '░'.repeat(5 - level);
                const iconText = icon.textContent.split(' ')[0];
                icon.textContent = `${iconText} ${bars}`;
            });
            
            // Save pet stats whenever they're updated
            savePetStats();
            
            // Check for happiness penalties when status changes
            checkHappinessPenalties();
        }

        // Update time display
        function updateTime() {
            const timeElement = document.querySelector('.time');
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            timeElement.textContent = timeString;
        }

        // Initialize game
        function init() {
            // Load saved data
            loadLearnedCharacters();
            loadSkippedCharacters();
            loadEvolutionData();
            loadPetStats();
            loadStreakData();
            loadTheme();
            loadSound();
            
            // Check and update streak
            checkAndUpdateStreak();
            
            // Update UI
            updateStatusBars();
            updatePetState();
            updateTime();
            setInterval(updateTime, 1000);
            
            // Initialize happiness penalty tracking
            checkHappinessPenalties();
            
            // Update menu counts
            updateFeedMenuCounts();
            updateStatsMenuCounts();
            updateSettingsMenuValues();
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('Lingoegg_theme') || 'sakura';
            applyTheme(savedTheme);
        }

        function saveTheme() {
            const currentTheme = gameState.currentTheme || 'sakura';
            localStorage.setItem('Lingoegg_theme', currentTheme);
        }

        function playTTS(text) {
            if ('speechSynthesis' in window) {
                const utter = new SpeechSynthesisUtterance();
                utter.text = text;
                utter.lang = 'zh-CN';
                // Try to select a Chinese voice if available
                const voices = window.speechSynthesis.getVoices();
                const zhVoice = voices.find(v => v.lang.startsWith('zh'));
                if (zhVoice) utter.voice = zhVoice;
                window.speechSynthesis.speak(utter);
            }
        }

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'a':
                case 'A':
                    buttonPress('A');
                    break;
                case 'b':
                case 'B':
                case 'Enter':
                    buttonPress('B');
                    break;
                case 'c':
                case 'C':
                case 'Escape':
                    buttonPress('C');
                    break;
                case 'ArrowUp':
                    if (gameState.currentView === 'memoryGame') {
                        navigateMemoryGame('up');
                    } else if (gameState.currentView === 'menu') {
                        navigateMenu('up');
                    }
                    break;
                case 'ArrowDown':
                    if (gameState.currentView === 'memoryGame') {
                        navigateMemoryGame('down');
                    } else if (gameState.currentView === 'menu') {
                        navigateMenu('down');
                    }
                    break;
                case 'ArrowLeft':
                    if (gameState.currentView === 'memoryGame') {
                        navigateMemoryGame('left');
                    }
                    break;
                case 'ArrowRight':
                    if (gameState.currentView === 'memoryGame') {
                        navigateMemoryGame('right');
                    }
                    break;
            }
        });

        // Start the game
        init();
    </script>
</body>
</html>
